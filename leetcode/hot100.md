# 128 最长连续子序列
`哈希`
```java
for(int x:st){
            if(st.contains(x-1))
                continue;
            y=x+1;
            while(st.contains(y))
                y++;
            ans=Math.max(ans,y-x);
        }
```
以x−1为起点计算出的序列长度，比以x为起点计算出的序列长度要长！避免重复计算

# 283 移动零
`双指针`
```java
        for(i=0,j=0;j<n;j++){
            if(nums[j]!=0){
                swap(nums,i,j);
                i++;
            }
        }
```
# 11 盛最多水的容器
`双指针`
```java
 while(i<=j){
            ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
            if(height[i]<height[j])
                i++;
            else
                j--;
        }
```
若向内移动短板 ，水槽的短板可能变大，因此下个水槽的面积可能增大
若向内移动长板 ，水槽的短板不变或变小，因此下个水槽的面积一定变小
故一定为向内移动短板
# 15 三数之和
`双指针`
```java
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L + 1] == nums[L])
                        L++;
                    while (L < R && nums[R - 1] == nums[R])
                        R--;
                    L++;
                    R--;
                }
```
在while判断之后，L和R记得同步变化。
asList的用法：```java ans.add(Arrays.asList(nums[i], nums[L], nums[R])); ```

# 3 无重复字符的最长子串
`滑动窗口` `哈希`
```java
for(int i=0;i<n;i++){
            if(i!=0)
                fir.remove(s.charAt(i-1));
            while(right+1<n && !fir.contains(s.charAt(right+1))){
                fir.add(s.charAt(right+1));
                right++;
            }
            ans=Math.max(ans,right-i+1);
        }
```
假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk
​。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。

# 438 找到字符串中所有字母异位词
`滑动窗口` `哈希` `字符串`
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n1 = s.length(), n2 = p.length(), differ = 0;
        if (n1 < n2)
            return new ArrayList<Integer>();
        List<Integer> ans = new ArrayList<Integer>();
//count[]用于记录s和p在窗口内的字符频率差异。>0表示s中该字符比p多，反之同理。
        int[] count = new int[26];
        for (int i = 0; i < n2; i++) {
            count[s.charAt(i) - 'a']++;
            count[p.charAt(i) - 'a']--;
        }
// 统计初始窗口和 p 的不同字符种类数
        for (int j = 0; j < 26; j++) {
            if (count[j] != 0)
                differ++;
        }
        if (differ == 0)
            ans.add(0);
#滑动窗口遍历s的剩余部分
        for (int i = 0; i < n1 - n2; i++) {
//移除窗口左边字符s[i]
            if (count[s.charAt(i) - 'a'] == 1)
                differ--;
            else if (count[s.charAt(i) - 'a'] == 0)
                differ++;
            count[s.charAt(i) - 'a']--;
//添加窗口右边新字符s[i+n2]
            if (count[s.charAt(i + n2) - 'a'] == -1)
                differ--;
            else if (count[s.charAt(i + n2) - 'a'] == 0)
                differ++;
            count[s.charAt(i+n2) - 'a']++;

            if (differ == 0)
                ans.add(i + 1);
        }
        return ans;
    }
}
```
滑动窗口的核心步骤：

移除窗口左端的字符 s[i]

如果 count[s[i]] == 1，表示 s[i] 在 s 比 p 多 1，删除后 differ--（差异减少）。
如果 count[s[i]] == 0，表示 s[i] 之前是匹配的，删除后 differ++（差异增加）。
更新 count[s[i]]--。
加入窗口右端的新字符 s[i+n2]

如果 count[s[i + n2]] == -1，表示 s[i + n2] 之前是 p 多 1，加入后 differ--（差异减少）。
如果 count[s[i + n2]] == 0，表示 s[i + n2] 之前匹配，加入后 differ++（差异增加）。
更新 count[s[i + n2]]++。
对于count[s[i + n2]] == 1的情况，则说明只有s[i + n2]之前刚好匹配 p，加入后才会 0 -> 1，但这种情况在滑动窗口过程中并不会影响 differ 计算的正确性

# 560 和为k的子数组
`前缀和` `哈希`
```java
//创建哈希表后需要添加元素(0,1),表示前缀和0出现过一次。
hashmap.getOrDefault(Object key, V defaultValue) //获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
hashmap.get(Object key) //获取指定 key 对应对 value
for(int i=0;i<n;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k))
                count+=map.get(pre-k);
            map.put(pre,map.getOrDefault(pre,0)+1);
        }
```




