# 128 最长连续序列
#哈希
`找出无序数组中数字连续的最长序列`
```java
//input:[100,4,200,1,3,2]  OUPUT:[1,2,3,4]长度为4
for(int x:st){
            if(st.contains(x-1))
                continue;
            y=x+1;
            while(st.contains(y))
                y++;
            ans=Math.max(ans,y-x);
        }
```
以x−1为起点计算出的序列长度，比以x为起点计算出的序列长度要长！避免重复计算

# 283 移动零
#双指针
`将数组中所有的0移动到数组的末尾`
```java
        for(i=0,j=0;j<n;j++){
            if(nums[j]!=0){
                swap(nums,i,j);
                i++;
            }
        }
```
# 11 盛最多水的容器
#双指针
```java
 while(i<=j){
            ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
            if(height[i]<height[j])
                i++;
            else
                j--;
        }
```
若向内移动短板 ，水槽的短板可能变大，因此下个水槽的面积可能增大
若向内移动长板 ，水槽的短板不变或变小，因此下个水槽的面积一定变小
故一定为向内移动短板
# 15 三数之和
#双指针
```java
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L + 1] == nums[L])
                        L++;
                    while (L < R && nums[R - 1] == nums[R])
                        R--;
                    L++;
                    R--;
                }
```
在while判断之后，L和R记得同步变化。
asList的用法：```java ans.add(Arrays.asList(nums[i], nums[L], nums[R])); ```

# 3 无重复字符的最长子串
#滑动窗口 #哈希
`给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度`
```java
for(int i=0;i<n;i++){
            if(i!=0)
                fir.remove(s.charAt(i-1));
            while(right+1<n && !fir.contains(s.charAt(right+1))){
                fir.add(s.charAt(right+1));
                right++;
            }
            ans=Math.max(ans,right-i+1);
        }
```
假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk
​。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。

# 438 找到字符串中所有字母异位词
#滑动窗口 #哈希 #字符串
`给定两个字串s和p，找出s中所有p的异位词(相同字母但是不同顺序)的字串，返回字串起始索引`
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n1 = s.length(), n2 = p.length(), differ = 0;
        if (n1 < n2)
            return new ArrayList<Integer>();
        List<Integer> ans = new ArrayList<Integer>();
        //count[]用于记录s和p在窗口内的字符频率差异。>0表示s中该字符比p多，反之同理。
        int[] count = new int[26];
        for (int i = 0; i < n2; i++) {
            count[s.charAt(i) - 'a']++;
            count[p.charAt(i) - 'a']--;
        }
        // 统计初始窗口和 p 的不同字符种类数
        for (int j = 0; j < 26; j++) {
            if (count[j] != 0)
                differ++;
        }
        if (differ == 0)
            ans.add(0);
        //滑动窗口遍历s的剩余部分
        for (int i = 0; i < n1 - n2; i++) {
            //移除窗口左边字符s[i]
            if (count[s.charAt(i) - 'a'] == 1)
                differ--;
            else if (count[s.charAt(i) - 'a'] == 0)
                differ++;
            count[s.charAt(i) - 'a']--;
            //添加窗口右边新字符s[i+n2]
            if (count[s.charAt(i + n2) - 'a'] == -1)
                differ--;
            else if (count[s.charAt(i + n2) - 'a'] == 0)
                differ++;
            count[s.charAt(i+n2) - 'a']++;

            if (differ == 0)
                ans.add(i + 1);
        }
        return ans;
    }
}
```
滑动窗口的核心步骤：

移除窗口左端的字符 s[i]

如果`count[s[i]] == 1`，表示 s[i] 在 s 比 p 多 1，删除后`differ--`（差异减少）。
如果`count[s[i]] == 0`，表示 s[i] 之前是匹配的，删除后`differ++`（差异增加）。
更新`count[s[i]]--`。
加入窗口右端的新字符 `s[i+n2]`

如果 `count[s[i + n2]] == -1`，表示 `s[i + n2]` 之前是 p 多 1，加入后 `differ--`（差异减少）。
如果 `count[s[i + n2]] == 0`，表示 `s[i + n2]` 之前匹配，加入后 `differ++`（差异增加）。
更新 `count[s[i + n2]]++`。
对于`count[s[i + n2]] == 1`的情况，则说明只有`s[i + n2]`之前刚好匹配 p，加入后才会 0 -> 1，但这种情况在滑动窗口过程中并不会影响 differ 计算的正确性

# 560 和为k的子数组
#前缀和 #哈希
```java
//创建哈希表后需要添加元素(0,1),表示前缀和0出现过一次。
hashmap.getOrDefault(Object key, V defaultValue) //获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
hashmap.get(Object key) //获取指定 key 对应对 value
for(int i=0;i<n;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k))
                count+=map.get(pre-k);
            map.put(pre,map.getOrDefault(pre,0)+1);
        }
```
# 42 接雨水
#双指针
```java
while(l<r){
            pre=Math.max(pre,height[l]);
            tail=Math.max(tail,height[r]);
            if(pre<tail){
                ans+=pre-height[l];
                l++;
            }
            else{
                ans+=tail-height[r];
                r--;
            }
        }
```
声明左右指针l,r;前缀后缀pre,tail.
遍历，依次求出pre、tail的最大值。
如果pre<tail,当前格能接的雨水则为pre-height[l],左指针右移
如果pre>=tail,当前格能接的雨水则为tail-height[r]，右指针左移

# 239 滑动窗口最大值
#单调队列 #滑动窗口
```java
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            //1.头：清理超期元素
            if (!deque.isEmpty() && deque.peek() == i - k) {
                deque.remove();
            }
            //2.尾：维护单调队列递减性，删除所有比新入队元素小的旧元素
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.removeLast();
            }
            //3.尾：新元素入队
            deque.add(i);
            //4.头：获取滑动窗口内最大值
            if(i>=k-1){
                ans[ansIndex] = nums[deque.peek()];
                ansIndex++;
            }
        }
```
创建双端队列后分成四部分来做(头尾尾头)，双端队列里面放的是**下标**
1.头：清理超期元素，即i-k位置的元素
滑动窗口的左边界始终是i-k+1，若deque.peek()==i-k,说明已经不在窗口[i-k,i]中
2.尾：维护单调队列递减性，删除所有比新入队元素小的旧元素
3.尾：新元素入队
4.头：获取滑动窗口内最大值
判断 **if(i>=k-1)** 是为了确保窗口已经形成，否则ans[ansIndex]可能越界。
比如i=k-1=2时，窗口[0,2]首次达到窗口值3,i<k-1时记录最大值没有意义

# 53 最大子数组和
#dp #前缀和
```java
//法一：前缀和
for(int x:nums) {
            pre += x;
            ans = Math.max(ans, pre - minPre);
            minPre = Math.min(pre, minPre);
        }
```
先计算完ans再去更新minPre。
```java
//法二：dp
 for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
```
动态转移方程 f(i)=max{f(i−1)+nums[i],nums[i]}
```java
//法三：线段树(尚未学习)
```

# 56 合并区间
#排序
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (p, q) -> p[0] - q[0]); // 按照左端点从小到大排序
        List<int[]> ans = new ArrayList<>();
        for (int[] p : intervals) {
            int m = ans.size();
            if (m > 0 && p[0] <= ans.get(m - 1)[1]) { // 可以合并
                ans.get(m - 1)[1] = Math.max(ans.get(m - 1)[1], p[1]); // 更新右端点最大值
            } else { // 不相交，无法合并
                ans.add(p); // 新的合并区间
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

# 41 缺失的第一个正数
#哈希
```java
public int firstMissingPositive(int[] nums) {
    int len = nums.length;
    
    // 第一轮：把所有正整数放到正确的位置
    for (int i = 0; i < len; i++) {
        while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
            // 交换 nums[i] 到它正确的位置 nums[nums[i] - 1]
            swap(nums, nums[i] - 1, i);
        }
    }

    // 第二轮：找出第一个不符合 nums[i] == i + 1 的位置
    for (int i = 0; i < len; i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    // 如果所有元素都正确，则返回 len + 1
    return len + 1;
}
```
1.由于缺失的最小正数一定在[1,len+1],故要通过交换元素调整数组中索引和值对应的状态，即nums[i]==i+1
交换的条件是：
- nums[i]为正数
- nums[i]不超过数组的长度
- nums[i]没有被放在正确的位置上nums[nums[i]-1]!=nums[i]
2.找出第一个不符合nums[i]==i+1的索引i，i+1就是缺失的最小正数
3.若数组已符合要求，则返回len+1

# 76 最小覆盖字串
#滑动窗口 #哈希
```java
import java.util.*;

class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return ""; // 边界情况：s 或 t 为空

        Map<Character, Integer> mapt = new HashMap<>(); // 统计 t 中每个字符的频次
        Map<Character, Integer> mapw = new HashMap<>(); // 记录窗口内字符的频次
        for (char c : t.toCharArray()) {
            mapt.put(c, mapt.getOrDefault(c, 0) + 1);
        }
        // 过滤 s 中无关字符，并存储 (字符, 原索引)
        List<int[]> filteredS = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (mapt.containsKey(c)) {
                filteredS.add(new int[]{c, i}); // 只保留 t 需要的字符
            }
        }
        int required = mapt.size(); // 需要满足的不同字符种类数
        int formed = 0; // 记录当前窗口满足条件的字符种类数
        int l = 0, r = 0; // 双指针窗口
        int minLen = Integer.MAX_VALUE, ansL = -1, ansR = -1; // 记录最小窗口
        // 进行滑动窗口搜索
        while (r < filteredS.size()) {
            char c = (char) filteredS.get(r)[0]; // 获取右指针的字符
            mapw.put(c, mapw.getOrDefault(c, 0) + 1);
            // 如果窗口中的 c 字符达到了 t 的要求，更新 formed
            if (mapw.get(c).equals(mapt.get(c)))    formed++;
            // 当窗口满足所有 t 中字符的要求时，开始收缩左边界
            while (formed == required) {
                char leftChar = (char) filteredS.get(l)[0]; // 获取左指针的字符
                int start = filteredS.get(l)[1]; // 获取左边界字符的原索引
                int end = filteredS.get(r)[1]; // 获取右边界字符的原索引
                // 记录当前最小窗口
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    ansL = start;
                    ansR = end + 1;
                }
                // 移除左边界字符
                mapw.put(leftChar, mapw.get(leftChar) - 1);
                if (mapw.get(leftChar) < mapt.get(leftChar)) {
                    formed--; // 如果移除的字符频次低于 t 需要的数量，则窗口不再满足条件
                }
                l++; // 移动左指针
            }
            r++; // 扩展右指针
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR); // 返回最小窗口子串
    }
}

```
## 预处理s，使其只保留t中的字符及索引
- 预处理s，找到所有属于t的字符及索引，存入filteredS，这样之后只需要在filteredS上操作
- 这样之后只需要在filteredS上操作滑动窗口

# 73 矩阵置0
#哈希 #矩阵
```java
for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                flagCol0 = true;//记录第一列是否有0
            }
            for (int j = 1; j < n; j++)  {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;//第一行和第一列作为标记
                }
            }
        }
        //根据标记置0
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (flagCol0) {
                matrix[i][0] = 0;//处理第一列
            }
        }
```
- 原地处理，使用第一行和第一列作为标记
# 54 螺旋矩阵
#矩阵
```java
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            //步骤1
            for (int column = left; column <= right; column++) {
                order.add(matrix[top][column]);
            }
            //步骤2
            for (int row = top + 1; row <= bottom; row++) {
                order.add(matrix[row][right]);
            }
            if (left < right && top < bottom) {
               //步骤3
                for (int column = right - 1; column > left; column--) {
                    order.add(matrix[bottom][column]);
                }
               //步骤4
                for (int row = bottom; row > top; row--) {
                    order.add(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
```
首先输出最外层的元素，然后输出最内层的元素（具体+1/-1可以改变，主要是思想）
- 从左到右遍历上侧元素:(top,left) -> (top,right)
- 从上到下遍历右侧元素:(top+1,right) -> (bottom,tight)
- 从右到左遍历底层元素:(bottom,right-1）-> (bottom,left+1)
- 从下到上遍历左侧元素:(bottom,left) -> (top+1,left)

步骤3和步骤4需要再次判断，避免在只有一行或一列的情况下重复访问

# 48 旋转图像
#矩阵
```java
public void rotate(int[][] matrix) {
    int n = matrix.length;  // 矩阵大小 N×N
    for (int i = 0; i < n / 2; ++i) {   // 遍历上半部分
        for (int j = 0; j < (n + 1) / 2; ++j) {  // 遍历左半部分
            int temp = matrix[i][j];  // 存储左上角的元素

            // 顺时针旋转 4 个元素
            matrix[i][j] = matrix[n - j - 1][i];  
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];  
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];  
            matrix[j][n - i - 1] = temp;  
        }
    }
}
```
主要思路就是顺时针旋转4个元素，记住顺序
然后记住遍历的顺序，i=n/2,j<(n+1)/2

# 4 寻找两个正序数组的中位数
#分治 #二分
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        int m = nums1.length;
        int n = nums2.length;
        int left = 0, right = m;

        int median1 = 0, median2 = 0;

        while (left <= right) {
            int i = (left + right) / 2;
            int j = (m + n + 1) / 2 - i;

            int nums_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]);
            int nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]);
            int nums_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]);
            int nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]);

            if (nums_im1 <= nums_j) {
                median1 = Math.max(nums_im1, nums_jm1);
                median2 = Math.min(nums_i, nums_j);
                left = i + 1;
            } else {
                right = i - 1;
            }
        }
        return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
    }
}
```
- 核心思想是分别将两个数组分为左右两部分，`max(nums1[i-1], nums2[j-1]) <= min(nums1[i], nums2[j])`
代表已经找到了正确的位置，即i、j代表的位置将数组分割为了正确的左右两部分。
- 假设前部分取了`nums1`的前`i`个元素，`nums2`的前`j`个元素，那么i+j=(m+n+1)/2
- `nums_im1` `nums_jm1`代表前半部分的最大值(最后一个数)， `nums_i` `nums_j`代表后半部分的最小值(第一个)。
i==0说明nums1没有左半部分，nums_im1设置为最小值；i==m说明nums1没有右半部分，设置为最大值
- 如果 nums_im1 <= nums_j，说明 i 是合适的分割点，更新 median1 和 median2。否则说明i取大了，right=i-1

# 240 搜索二维矩阵Ⅱ
#二分 #分治
```java
int m=matrix.length,n=matrix[0].length;
        int x=0,y=n-1;
        while(x<m && y>=0){
            if(matrix[x][y]==target)
                return true;
            else if(matrix[x][y]<target)
                x++;
            else if(matrix[x][y]>target)
                y--;
        }
```
从右上角开始遍历

# 160相交链表，206反转链表，21 合并有序链表
```java
//相交矩阵，返回相交的起始节点
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        while (p != q) {
            p = p != null ? p.next : headB;
            q = q != null ? q.next : headA;
        }
        return p;
    }
```
x为链表A不同的距离，y为链表B不同的距离，z为共同的距离：(x+z)+y=(y+z)+x
每次循环，p 和 q 各向后走一步。如果 p 非空，那么更新 p 为 p.next，否则更新 p 为 headB；如果 q非空，那么更新 q 为 q.next，否则更新 q 为 headA。

```java
//反转链表 迭代法，头插法
    public ListNode reverseList(ListNode head) {
        ListNode cur=head,prev=null;
        while(cur!=null){
            ListNode next=cur.next;
            cur.next=prev;
            prev=cur;
            cur=next;
        }
        return prev;
    }
```
要交换的对象只有pre和cur指针，next指针只是一个锚点。
在考虑这道题的时候，不要像之前一样考虑头插的过程，只需要考虑把箭头反转就可以。

```java
//合并链表
        ListNode list=new ListNode(-1);
        ListNode prev=list;
        while(list1!=null && list2!=null){
            if(list1.val<=list2.val){
                prev.next=list1;
                list1=list1.next;
            }
            else{
                prev.next=list2;
                list2=list2.next;
            }
            prev=prev.next;
        }
        prev.next=list1==null?list2:list1;
        return list.next;
```
创建新节点val为-1，再用另一个指针进行操作。

# 142 环形链表
#双指针
```java
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
```
假设环外的长度为a，slow入环之后又走了b与fast相遇，c为环中剩余的距离。此时fast指针已经走完了n圈，故其走过的总距离为a+n(b+c)+b=a+(n+1)b+nc.
fast距离为slow的2倍，故a+(n+1)b+nc=2(a+b),可得a=c+(n-1)(b+c)
即从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。
使用指针ptr指向head，在快慢指针相遇之后与slow同时向前移动，最终会在入环点相遇

# 2 两数相加
```java
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;//进位值
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null)
                l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
        }
        if (carry > 0)
            tail.next = new ListNode(carry);
        return head;
    }
```
链表中对应位置的值为`(n1+n2+carry) mod 10`,新的进位值为`(n1+n2+carry) / 10`
如果链表遍历结束后，有carry>0，还需要在答案链表的后面附加一个节点，节点的值为carry。

```java
    public ListNode swapPairs(ListNode head) {
        ListNode tmp = new ListNode(0,head);
        ListNode node0=tmp,node1=head;
        while(node1!=null && node1.next!=null){
            ListNode node2=node1.next;
            ListNode node3=node2.next;

            node0.next=node2;
            node2.next=node1;
            node1.next=node3;

            node0=node1;
            node1=node3;
        }
        return tmp.next;
    }
```
假设有序列`[0,1,2,3,4,5]`,node的序号代表最开始指向了哪个值。
0作为哨兵，先把0指向2，2指向1，1指向3。此时顺序为`[0,2,1,3]`,此时1就是上一步的node0的作用。

# 25 k个一组翻转链表
```java
    public ListNode reverseKGroup(ListNode head, int k) {
        int n=0;
        for(ListNode cur=head;cur!=null;cur=cur.next)
            n++;
        ListNode tmp=new ListNode(0,head);
        ListNode p0=tmp,pre=null,cur=head;
        for(;n>=k;n-=k){
            for(int i=0;i<k;i++){
                ListNode nxt=cur.next;
                cur.next=pre;
                pre=cur;
                cur=nxt;
            }
            
            ListNode nxt=p0.next;
            p0.next.next=cur;
            p0.next=pre;
            p0=nxt;
        }
        return tmp.next;
    }
```
![image](https://github.com/user-attachments/assets/39dd5be5-4584-4a47-9d57-78e8bd956a98)
p0.next.next指向cur，p0.next指向pre.

# 138 随机链表的复制
```java
public Node copyRandomList(Node head) {
        if (head == null)
            return null;

        //遍历中复制每一个节点, 并把新节点插在原节点的后面
        for (Node cur = head; cur != null; cur = cur.next.next)
            cur.next = new Node(cur.val, cur.next);

        //遍历链表,解决random指针
        for (Node cur = head; cur != null; cur = cur.next.next) {
            if (cur.random != null)
                //cur.random的next节点即为random节点的复制节点
                cur.next.random = cur.random.next;
        }

        //将新链表分离出来
        Node newHead = head.next;
        Node cur = head;
        for (; cur.next.next != null; cur = cur.next) {
            Node tmp = cur.next; //指向第一个新节点
            cur.next = tmp.next; //老节点指针指向下一个老节点，也就是tmp.next
            tmp.next = tmp.next.next; //新节点指向下一个新节点
        }
        cur.next = null;//遍历到最后一个老节点，指向null
        return newHead;
    }
```
需要注意的是两次遍历cur=cur.next.next,重点理解random指针部分和最后的分离部分
$$1\longrightarrow1^{'}\longrightarrow2\longrightarrow2^{'}\longrightarrow3\longrightarrow3^{'}$$

# 23 合并k个升序链表
#优先队列 #最小堆 #分治
```java
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
        for (ListNode head : lists) {
            if (head != null)
                pq.offer(head); // 把所有非空链表的头节点入堆
        }

        ListNode Sentinel = new ListNode();
        ListNode cur = Sentinel;
        while (!pq.isEmpty()) {//循环直至堆为空
            ListNode node = pq.poll();//最小节点
            if (node.next != null)
                pq.offer(node.next);//下一个节点有可能为最小节点，入堆

            cur.next = node;//把node添加到新节点的末尾
            cur = cur.next;//准备合并下一个节点
        }
        return Sentinel.next;
    }
```
最小堆做法：初始把所有链表头节点入堆，然后不断弹出堆中最小节点x，如果x.next不为空就加入堆中，把弹出的节点按顺序拼接。实现时，可以用哨兵节点Sentinel简化代码。
时间复杂度为O(nlogk)，空间复杂度为O(k)

```java
public ListNode mergeKLists(ListNode[] lists) {
        return mergeKLists(lists, 0, lists.length);
    }

    // 合并从 lists[i] 到 lists[j-1] 的链表
    private ListNode mergeKLists(ListNode[] lists, int i, int j) {
        int m = j - i;
        if (m == 0) {
            return null; // 注意输入的 lists 可能是空的
        }
        if (m == 1) {
            return lists[i]; // 无需合并，直接返回
        }
        ListNode left = mergeKLists(lists, i, i + m / 2); // 合并左半部分
        ListNode right = mergeKLists(lists, i + m / 2, j); // 合并右半部分
        return mergeTwoLists(left, right); // 最后把左半和右半合并
    }

    // 21. 合并两个有序链表
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(); // 用哨兵节点简化代码逻辑
        ListNode cur = dummy; // cur 指向新链表的末尾
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1; // 把 list1 加到新链表中
                list1 = list1.next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur.next = list2; // 把 list2 加到新链表中
                list2 = list2.next;
            }
            cur = cur.next;
        }
        cur.next = list1 != null ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }
```
时间复杂度为O(nlogk)，空间复杂度为O(logk)

# 148 排序链表
#归并
```java
    public ListNode sortList(ListNode head) {
        if(head==null || head.next==null)
            return head;
        
        //找到链表中点
        ListNode slow=head,fast=head.next;
        while(fast!=null && fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
        }

        //拆分链表为两半,[head,slow],[slow.next,end]
        ListNode mid=slow.next;//右半半部分起点
        slow.next=null;//断开链表

        ListNode left=sortList(head);
        ListNode right=sortList(mid);

        return merge(left,right);
    }
    private ListNode merge(ListNode l1,ListNode l2){
        ListNode Sentinel =new ListNode(0);
        ListNode cur=Sentinel;
        //双指针遍历两个链表，合并
        while(l1!=null && l2!=null){
            if(l1.val<l2.val){
                cur.next=l1;
                l1=l1.next;
            }
            else{
                cur.next=l2;
                l2=l2.next;
            }
            cur=cur.next;
        }
        cur.next=(l1!=null)?l1:l2;
        return Sentinel.next;
    }
```
核心思想，先通过快慢指针找到链表的中点，然后把链表断为左右两部分。
归并过程就是通过双指针，依次比较值的大小。

# 146 LRU缓存
```java
    private final int capacity;
    private final Node Sentinel = new Node(0, 0);
    private final Map<Integer, Node> keyToNode = new HashMap<>();

    private static class Node {
        int key, value;
        Node prev, next;
        Node(int k, int v) {
            this.key = k;
            this.value = v;
        }
    }

    public LRUCache(int capacity) {
        this.capacity = capacity;
        Sentinel.next = Sentinel;
        Sentinel.prev = Sentinel;
    }

    public int get(int key) {
        Node node = getNode(key);
        return node != null ? node.value : -1;
    }

    public void put(int key, int value) {
        Node node = getNode(key);
        if (node != null) {
            node.value = value;
            return;
        }
        node = new Node(key, value);
        keyToNode.put(key, node);
        pushFront(node);
        if (keyToNode.size() > capacity) {
            Node backNode = Sentinel.prev;
            keyToNode.remove(backNode.key);
            remove(backNode);
        }
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    private Node getNode(int key) {
        if (!keyToNode.containsKey(key))
            return null;
        Node node = keyToNode.get(key);
        remove(node);
        pushFront(node);
        return node;
    }

    // 删除一个节点
    private void remove(Node n) {
        n.prev.next = n.next;
        n.next.prev = n.prev;
    }

    // 在链表头添加一个节点
    private void pushFront(Node n) {
        n.prev = Sentinel;
        n.next = Sentinel.next;
        n.prev.next = n;
        n.next.prev = n;
    }
```
`get(int key)`:查找key，把对应系欸但移动到链表头(表示刚使用过)
`put(int key,int value)`:取出key对应的节点并移到头部，存在则更新值，不存在则创建。超出容量移除链表尾
`getNode(int key)`:找到key对应的节点，先从原位置移除再放到表头

# 226 翻转二叉树  101 对称二叉树  543 二叉树的直径
#递归
```java
TreeNode left=invertTree(root.left);
TreeNode right=invertTree(root.right);
root.left=right;
root.right=left;
return root;
```
```java
public boolean check(TreeNode p,TreeNode q){
        if(p==null && q==null)
            return true;
        if(p==null || q==null)
            return false;
        return p.val==q.val && check(p.left,q.right) && check(p.right,q.left);
    }
```
```java
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return ans;
    }
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        ans = Math.max(left + right, ans);
        return Math.max(left, right) + 1;
    }
```
`return`语句+1：在计算当前节点的最大深度时，要算上自己这一层

# 102 二叉树层序遍历
```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        //用于存放每一层的节点值
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        if (root != null)
            queue.add(root);
        while (!queue.isEmpty()) {
            //当前队列节点数，即当前层的节点数
            int n = queue.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            ans.add(level);
        }
        return ans;
    }
```

```java
    public List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return result;
        bfs(root,0);
        return result;
    }

    public void bfs(TreeNode root, int height){
        if(root == null) return;
        // 如果结果列表中还没有当前层的子列表，则创建一个新的子列表并加入结果列表
        if(result.size() <= height){
            List<Integer> temp = new ArrayList<Integer>();
            result.add(temp);
        }
        // 获取当前深度对应的子列表
        List<Integer> temp = result.get(height);
        // 将当前节点的值加入当前层的子列表
        temp.add(root.val);

        bfs(root.left, height+1);
        bfs(root.right, height+1);
    }
```
# 108 有序数组转化为二叉搜索树
```java
    public TreeNode sortedArrayToBST(int[] nums) {
        return devide(nums, 0, nums.length - 1);
    }
    public TreeNode devide(int[] nums, int left, int right) {
        if (left > right)
            return null;
        int mid = (left + right) >> 1;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = devide(nums, left, mid - 1);
        root.right = devide(nums, mid + 1, right);
        return root;
    }
```

# 98 验证二叉搜索树
```java
    //用来记录 中序遍历中“前一个节点”的值；
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null)
            return true;
        if (!isValidBST(root.left) || root.val <= pre)
            return false;
        pre = root.val;
        return isValidBST(root.right);
    }
```
# 230 二叉搜索树第k小的元素
```java
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        return dfs(root);
    }
    private int dfs(TreeNode Node) {
        if (Node == null)
            return -1;
        int left = dfs(Node.left);
        if (left != -1)
            return left;
        if (--k == 0)//每处理一个节点，k-1
            return Node.val;
        return dfs(Node.right);
    }
```
中序遍历

# 199 二叉树的右视图
```java
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans= new ArrayList<>();
        dfs(root,0,ans);
        return ans;
    }
    private void dfs(TreeNode root,int depth,List<Integer> ans){
        if(root==null)
            return;
        if(ans.size()==depth)// 这个深度首次遇到
            ans.add(root.val);
        dfs(root.right,depth+1,ans);
        dfs(root.left,depth+1,ans);
    }
```

# 114 二叉树展开为链表
```java
    public void flatten(TreeNode root) {
        TreeNode curr = root;
        while (curr != null) {
            if (curr.left != null) {
                TreeNode next = curr.left;
                TreeNode predecessor = next;
                while (predecessor.right != null) {
                    predecessor = predecessor.right;
                }
                predecessor.right = curr.right;
                curr.left = null;
                curr.right = next;
            }
            curr = curr.right;
        }
    }
```

# 105 从前序和中序构造二叉树
```java
class Solution {
    private Map<Integer, Integer> indexMap; // 哈希表，存储每个节点值在中序遍历中的位置
    // 根据给定的前序遍历和中序遍历区间，递归构建二叉树
    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        // 如果当前区间无效，返回 null
        if (preorder_left > preorder_right)
            return null;
        int preorder_root = preorder_left;// 前序遍历的第一个节点是当前子树的根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);// 在中序遍历中找到根节点的位置

        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 计算左子树的节点数目，然后递归构建左右子树
        int size_left_subtree = inorder_root - inorder_left;
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    // 主函数：根据前序遍历和中序遍历构建整个二叉树
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        
        // 构造哈希映射，帮助快速定位中序遍历中根节点的位置
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i); // 记录每个值在中序遍历中的索引
        }
        // 从前序和中序遍历的完整区间开始递归构建树
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}
```
# 437 路径总和Ⅲ
#前缀和
```java
    private HashMap<Long, Integer> prefixSum = new HashMap<>();  // 用于存储路径和的前缀和及其出现次数
    public int pathSum(TreeNode root, int targetSum) {
        prefixSum.put(0L, 1);  // 初始化，表示路径和为0出现了一次。这是为了处理从根节点开始就满足 targetSum 的情况
        dfs(root, 0L, (long) targetSum);  // 从根节点开始递归，初始路径和为0，目标和为targetSum
        return result;  // 返回符合条件的路径数目
    }
    private void dfs(TreeNode node, long currentSum, long targetSum) {
        if (node == null) return; 
        currentSum += node.val; // 更新当前路径和，加上当前节点的值
        // 判断当前路径和减去目标和是否在前缀和中存在
        result += prefixSum.getOrDefault(currentSum - targetSum, 0);  // 如果存在，说明有路径和为 targetSum，增加结果
        // 更新前缀和：记录当前路径和出现的次数
        prefixSum.put(currentSum, prefixSum.getOrDefault(currentSum, 0) + 1);
        // 递归遍历左子树和右子树
        dfs(node.left, currentSum, targetSum);
        dfs(node.right, currentSum, targetSum);
        // 回溯，恢复前缀和的状态
        prefixSum.put(currentSum, prefixSum.get(currentSum) - 1);  // 当遍历完当前节点的左右子树后，回溯时减少当前路径和的出现次数
    }
```

# 236 二叉树的最近公共祖先
```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || root==p ||root==q)
            return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        //左右子树都找到了p or q,则当前节点root就是所求
        if(left!=null && right!=null)
            return root;
        //否则转到非空的树去寻找
        return left!=null?left:right;
    }
```
# 二叉树的最大路径和
```java
 private int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }
    private int dfs(TreeNode node) {
        if (node == null)
            return 0;
        int lVal = dfs(node.left);//左子树最大链和
        int rVal = dfs(node.right);//右子树最大链和 
        ans = Math.max(ans, lVal + rVal + node.val);//左+右+节点，拼成路径
        return Math.max(Math.max(lVal, rVal) + node.val, 0);//当前字数最大链和
    }
```
# 岛屿问题
```java
    //通解dfs模板
    void dfs(char[][] grid, int r, int c) {
        if (!inArea(grid, r, c))
            return;
        if (grid[r][c] != '1')
            return;
        grid[r][c] = '2';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    boolean inArea(char[][] grid, int r, int c) {
        return 0 <= r && r < grid.length && c >= 0 && c < grid[0].length;
    }
```
# 994 腐烂的橘子
#BFS #队列
```java
    private static final int[][] DIR = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };
    public int orangesRotting(int[][] grid) {
        int m = grid.length, n = grid[0].length; // 获取网格的行数和列数
        int fresh = 0; // 统计新鲜橘子的数量
        Queue<int[]> q = new LinkedList<>(); // 存放腐烂橘子的队列

        for (int i = 0; i < m; i++) {//统计初始的好坏橘子
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) // 如果是新鲜橘子
                    fresh++;
                else if (grid[i][j] == 2) // 如果是腐烂橘子
                    q.offer(new int[] { i, j });
            }
        }
        int ans = 0; // 记录经过的分钟数
        // 当还有新鲜橘子且有腐烂橘子可以传播时
        while (fresh > 0 && !q.isEmpty()) {
            ans++; // 每轮代表一分钟
            int size = q.size(); // 当前层次的腐烂橘子数量
            // 遍历当前层次的腐烂橘子
            for (int k = 0; k < size; k++) {
                int[] pos = q.poll();
                for (int[] d : DIR) {
                    int i = pos[0] + d[0];
                    int j = pos[1] + d[1];
                    // 判断是否越界且是否为新鲜橘子
                    if (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1) {
                        fresh--; // 新鲜橘子数量减少
                        grid[i][j] = 2; // 将新鲜橘子腐烂
                        q.offer(new int[] { i, j }); // 加入腐烂橘子的队列
                    }
                }
            }
        }
        return fresh > 0 ? -1 : ans;
```
当前层次即刚被感染的橘子，然后把统计这些橘子的数量然后由他们作为污染源进行传播
# 207 课程表
#拓扑
```java
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 构建邻接表表示有向图,graph[x]表示所有依赖于x的课程
        List<List<Integer>> graph = new ArrayList<>(numCourses);
        for (int i = 0; i < numCourses; i++)
            graph.add(new ArrayList<>());
        // 填充邻接表,p[1]为先修课程,p[0]为目标课程
        for (int[] p : prerequisites)
            graph.get(p[1]).add(p[0]);

        int[] visited = new int[numCourses]; // 标记节点状态：0-未访问，1-访问中，2-已访问
        //如果还没有被访问则检测是否有环
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0 && hasCycle(i, graph, visited))
                return false; // 存在环，不能完成课程
        }
        return true; // 无环，可以完成课程
    }

    // 深度优先搜索检测环
    private boolean hasCycle(int course, List<List<Integer>> graph, int[] visited) {
        visited[course] = 1; // 标记为访问中
        for (int next : graph.get(course)) { // 遍历邻接节点
            // 如果邻接节点是访问中，说明存在环
            if (visited[next] == 1)
                return true;
            // 如果邻接节点未访问且递归检测到环
            if (visited[next] == 0 && hasCycle(next, graph, visited))
                return true;
        }
        visited[course] = 2; // 标记为已访问
        return false;
    }
```
判断`visited[1]==1`只出现在判断函数中，不出现在主函数中，主函数只负责启动dfs，在主函数中只有未访问的节点才需要启动新dfs。
检测函数中，遍历graph中依赖于某课程的其余课程时，只需要判断1和0的情况，2仅需遍历之后做标记。

# 208 实现前缀树
#哈希
```java
    private static class Node {
        Node[] children = new Node[26];//子节点数组
        boolean isEnd;//标记单词结束
    }
    private Node root = new Node();
    public void insert(String word) {
        Node current=find(word,true);
        current.isEnd=true;
    }
    public boolean search(String word) {
        Node node=find(word,false);
        return node!=null && node.isEnd;
    }
    public boolean startsWith(String prefix) {
        return find(prefix,false)!=null;
    }
    //查找并创建节点
    private Node find(String word,boolean needCreate){
        Node current=root;
        for(char c:word.toCharArray()){
            int index=c-'a';
            //子节点不存在，根据情况是否需要创建
            if(current.children[index]==null){
                if(needCreate)
                    current.children[index]=new Node();
                else
                    return null;
            }
            current=current.children[index];
        }
        return current;
    }
```
insert函数需要设置`isEnd=true`
search函数先判断`node!=null`表示从根节点找到了目标节点，即路径存在。然后判断`isEnd`表示是一个完整的单词

# 46 全排列
#回溯
```java
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<>>();
        List<Integer> output = new ArrayList<>();
        for (int num : nums)//初始化排列列表，将元素逐一加入
            output.add(num);
        int n = nums.length;
        backtrack(n, 0, output, ans);
        return ans;
    }
    public void backtrack(int n, int index, List<Integer> output, List<List<Integer>> ans) {
        if (index == n)//排列长度等于数组长度时，将当前的output加入ans
            ans.add(new ArrayList<Integer>(output));
        for (int i = index; i < n; i++) {
            //1.交换：将index和i交换位置
            Collections.swap(output, index, i);
            //2.递归：排列下一个位置
            backtrack(n, index + 1, output, ans);
            //3.回溯：把index和i交换回来
            Collections.swap(output, index, i);
        }
    }
```
index代表当前固定位置，逐步固定元素之后，再交换index之后的元素位置，然后再回溯。

# 78 子集
#回溯
```java
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        backtrack(0, nums, ans, new ArrayList<>());
        return ans;
    }
    public void backtrack(int index, int[] nums, List<List<Integer>> ans, List<Integer> path) {
        //把当前路径加入答案列表
        ans.add(new ArrayList<>(path));
        int len = nums.length;
        for (int i = index; i < len; i++) {
            //当前元素加入路径
            path.add(nums[i]);
            //继续向后寻找包含当前元素的后续子集
            backtrack(i + 1, nums, ans, path);
            //回溯，移除最后一个加入的元素
            path.remove(path.size() - 1);
        }
    }
```

# 17 电话号码的字母组合
#回溯
```java
    List<String> ans = new ArrayList<>();
    StringBuilder temp = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0)
            return ans;
        String[] numString = { "", "", "abc", "def", "ghi", \
            "jkl", "mno", "pqrs", "tuv", "wxyz" };
        backTracking(digits, numString, 0);
        return ans;
    }
    //index 当前处理的数字位置的索引
    public void backTracking(String digits, String[] numString, int index) {
        if (num == digits.length()) {
            list.add(temp.toString());
            return;
        }
        String str = numString[digits.charAt(index) - '0'];
        for (int i = 0; i < str.length(); i++) {
            //将字母加入当前组合
            temp.append(str.charAt(i));
            //递归，继续生成下一位数字的组合
            backTracking(digits, numString, index + 1);
            //回溯
            temp.deleteCharAt(temp.length() - 1);
        }
    }
```
java处理字符串先定义stringBuilder对象
# 38 组合总和
#回溯
```java
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> ans = new ArrayList();
        List<Integer> path = new ArrayList();
        backtrack(target, 0, candidates, ans, path);
        return ans;
    }
    public void backtrack(int target, int index, int[] candidates, List<List<Integer>> ans, List<Integer> path) {
        if (target == 0) {
            ans.add(new ArrayList<>(path));
            return;
        }
        if (target < candidates[index])
            return;
        for (int i = index; i < candidates.length; i++) {
            path.add(candidates[i]);
            backtrack(target - candidates[i], i, candidates, ans, path);
            path.remove(path.size() - 1);
        }
    }
```
先将`canditates`排序，依旧回溯

# 22 括号生成
#递归
```java
    public List<String> generateParenthesis(int n) {
        List<String>ans=new ArrayList<>();
        dfs("",n,n,ans);
        return ans;
    }
    public void dfs(String str,int left,int right,List<String> ans){
        //左右括号都为0，说明生成了一个合法组合
        if(left==0 && right==0)
            ans.add(str);
        if(left>0)
            dfs(str+"(",left-1,right,ans);
        if(left<right)
            dfs(str+")",left,right-1,ans);
    }
```
left为剩余可以放置的左括号数量，right为剩余可以放置的右括号数量
1. 如果还有左括号可以放，就递归地添加一个左括号
2. 如果右括号数量多于左括号，说明可以放右括号

# 51 N皇后
#回溯 #位运算
```java
    List<List<String>> ans=new ArrayList<>();
    char[][] board;
    public List<List<String>> solveNQueens(int n) {
        board=new char[n][n];
        for(char[] row:board)
            Arrays.fill(row,'.');
        backtrack(0,0,0,0,n);
        return ans;
    }
    public void backtrack(int row,int a,int b,int c,int n){
        if(row==n){
            List<String> tmp=new ArrayList<>();
            for(char[] r:board)
                tmp.add(new String(r));
            ans.add(tmp);
        }
        int mask=(1<<n)-1;
        int available=~(a|b|c) &mask;
        while(available>0){
            int bit=available & -available;
            int col=Integer.numberOfTrailingZeros(bit);
            board[row][col]='Q';
            backtrack(row+1,(a|bit)<<1,b|bit,(c|bit)>>1,n);
            board[row][col]='.';
            available-=bit;
        }
    }
```
(a：主对角线，b：当前列，c：副对角线)是否有皇后

`mask=(1 << n) - 1`用来创建一个后n位均为1的二进制数，`a|b|c`把三个障碍位合并，得到所有不能放皇后的地方，取反则为能放的位置，`&mask`操作则用于清除高位无关信息，只保留1

计算bit的操作则为提取available中第一个1，`numberOfTrailingZeros(bit)`则为bit末尾几个0，也就是1在从右往左第几位，也就是皇后应该放到哪一列

# 74 搜索二维矩阵
#二分
```java
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int left = 0, right = m * n-1;
        while(left<=right){
            int mid=(left+right)>>1;
            int x=matrix[mid/n][mid%n];
            if(x==target)
                return true;
            else if(x<target)
                left=mid+1;
            else
                right=mid-1;
        }
        return false;
    }
```
将二维数组看作一维数组,数组下标i,j与位置k的关系：```java i = k / n,j = k % n;```
注意边界条件，采用闭区间[0,mn-1];

# 34 在排序数组中查找元素的第一个和最后一个位置
#二分
```java
    public int[] searchRange(int[] nums, int target) {
        int start=lowerBound(nums,target);
        if(start==nums.length || nums[start]!=target)
            return new int[]{-1,-1};
        int end=lowerBound(nums,target+1)-1;
        return new int[]{start,end};
    }
    public int lowerBound(int[] nums,int target){
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=(left+right)>>1;
            if(nums[mid]>=target)
                right=mid-1;
            else
                left=mid+1;
        }
        return left;
    }
```
依旧闭区间

# 33 搜索旋转排序数组
#二分
```java
    public int search(int[] nums, int target) {
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=(left+right)>>1;
            if(check(mid,target,nums))
                right=mid-1;
            else
                left=mid+1;
        }
        //left指向第一个满足条件的位置，也可能是找不到的插入点(注意最后的返回条件)
        if(left<nums.length && nums[left]==target)
            return left;
        return -1;
    }
    public boolean check(int index,int target,int[] nums){
        int mid=nums[index];//中间元素
        int end=nums[nums.length-1];//末尾元素
        if(mid>end)//nums被分为两段，前半部分比较大【3，4，5，6，1，2】
            return target>end && mid>=target;
        return target>end || mid>=target;
    }
```
`check`函数判断target在mid的左侧还是右侧(重中之重)，左侧为true，右侧为false
先判断`mid`在哪段：如果`mid > end`，说明在左段，否则在右段
再判断 target 是不是在 mid 的“左边”：在同一段：看大小关系,不在一段：看是不是左段或右段

# 寻找旋转排序数组中的最小值
#二分
```java
    public int findMin(int[] nums) {
        int n = nums.length;
        int left = 0, right = n - 1;
        while (left < right) {
            int mid = (left+right)>>1;
            if (nums[mid] <= nums[right]) {
                right = mid; // 包含 mid
            } else {
                left = mid + 1; // 排除 mid
            }
        }
        return nums[left];
    }
```

# 有效的括号
#栈
```java
    public boolean isValid(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) return false;
                char top = stack.pop();
                if ((c == ')' && top != '(') ||
                    (c == ']' && top != '[') ||
                    (c == '}' && top != '{')) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
```
循环遍历字符串，碰见左括号则入栈，碰见右括号则看栈顶是否匹配。注意栈的isEmpty()用法

# 字符串解码
#栈
```java
    public String decodeString(String s) {
        Deque<Integer> countStack=new ArrayDeque<>();
        Deque<StringBuilder> stringStack=new ArrayDeque<>();
        StringBuilder cur=new StringBuilder();
        int k=0;
        for(char ch:s.toCharArray()){
            if(Character.isDigit(ch))
                k=k*10+ch-'0';
            else if(ch=='['){
                //马上碰见新的字符时，先保存次数k，并把之前的字符串入栈保存
                countStack.push(k);
                stringStack.push(cur);
                cur=new StringBuilder();
                k=0;
            }
            else if(ch==']'){
                //结束一个字符串，弹出k和之前字符串，并把正在处理的拼接在prev之后
                int tmp=countStack.pop();
                StringBuilder prev=stringStack.pop();
                for(int i=0;i<tmp;i++)
                    prev.append(cur);
                cur=prev;
            }
            else{
                cur.append(ch);
            }
        }
        return cur.toString();
    }
```
stringStack存放每次遇到'['之前已经构造的字符串，countStack存放数字k，cur为当前正在处理的字符串

# 每日温度
#栈
```java
    public int[] dailyTemperatures(int[] temperatures) {
        int len=temperatures.length;
        int[] ans=new int[len];
        Deque<Integer> stack=new LinkedList<Integer>();
        for(int i=0;i<len;i++){
            int tmp=temperatures[i];
            while(!stack.isEmpty() && tmp>temperatures[stack.peek()]){
                int prevIndex=stack.pop();
                ans[prevIndex]=i-prevIndex;
            }
            stack.push(i);
        }
        return ans;
    }
```
peek获取索引，栈中寸的是索引

# 84 柱状图中最大的矩形
#栈
```java
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int ans = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i <= n; i++) {
            //获取当前高度，i==n时视为0(哨兵)
            int curHeight = (i == n) ? 0 : heights[i];
            //当前柱子高度小于栈顶柱子时开始计算面积
            while (!stack.isEmpty() && curHeight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                //栈空了，说明左边没有比他小的柱子，宽度为i。否则宽度为后者
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                ans = Math.max(ans, height * width);
            }
            //当前柱子的下标入栈
            stack.push(i);
        }
        return ans;
    }
```
for循环的条件为`i<=n`
栈中保存的是递增的柱子下标，也就是说，栈顶的柱子是到目前为止最高的、尚未结算面积的柱子。
`i==n`时，哨兵=0的作用是“我比你们都矮，你们都别等了，都赶紧结算吧”,把之前入栈但未处理的柱子全部计算面积。

# 215 数组中的第K个最大元素
#快排
```java
    public int findKthLargest(int[] nums, int k) {
        int n=nums.length;
        return quickSelect(nums,0,n-1,n-k);
    }
    public int quickSelect(int[] nums,int l,int r,int k){
        if(l==r) return nums[k];
        int pivot=nums[l],i=l,j=r;
        while(i<=j){
            while(i<=j && nums[i]<pivot)    i++;
            while(i<=j && nums[j]>pivot)    j--;
            if(i>=j)    break;
            swap(nums,i,j);
            i++;
            j--;
        }
        return (k<=j)?quickSelect(nums,l,j,k):quickSelect(nums,j+1,r,k);
    }
    public void swap(int[] nums,int a,int b){
        int tmp=nums[a];
        nums[a]=nums[b];
        nums[b]=tmp;
    }
```
主要就是主函数调用时`quickSelect(nums,0,n-1,n-k)`,快排本质是找第k小的元素，所以要进行转化。

# 347 前K个高频元素
#桶排序
```java
    public int[] topKFrequent(int[] nums, int k) {
        // 第一步：统计每个元素的出现次数
        Map<Integer, Integer> cnt = new HashMap<>();
        for (int x : nums) {
            cnt.put(x, cnt.getOrDefault(x,0)+1); // cnt[x]++
        }
        int maxCnt = Collections.max(cnt.values());
        // 第二步：把出现次数相同的元素，放到同一个桶中
        List<Integer>[] buckets = new ArrayList[maxCnt + 1];
        Arrays.setAll(buckets, i -> new ArrayList<>());
        for (Map.Entry<Integer, Integer> e : cnt.entrySet()) {
            buckets[e.getValue()].add(e.getKey());
        }
        // 第三步：倒序遍历 buckets，把出现次数前 k 大的元素加入答案
        int[] ans = new int[k];
        int j = 0;
        for (int i = maxCnt; i >= 0 && j < k; i--) {
            for (int x : buckets[i]) {
                ans[j++] = x;
            }
        }
        return ans;
    }
```
`Arrays.setAll(buckets, i -> new ArrayList<>());`相当于
```java
for (int i = 0; i < buckets.length; i++) {
    buckets[i] = new ArrayList<>();
}
```
倒序遍历的时候：倒序遍历桶，从高频到低频，把桶内的元素一个一个放入答案数组中，直到凑够 k 个。

# 295 数据流的中位数
#堆
```java
    PriorityQueue<Integer> maxHeap;
    PriorityQueue<Integer> minHeap;
    public MedianFinder() {
        maxHeap = new PriorityQueue<>((a, b) -> (b - a));
        minHeap = new PriorityQueue<>((a, b) -> (a - b));
    }
    public void addNum(int num) {
        // 如果大根堆为空或num小于等于大根堆的堆顶，加入大根堆
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {
            maxHeap.offer(num);
            // 保持平衡：大根堆的大小不能超过小根堆的大小 + 1
            if (maxHeap.size() > minHeap.size() + 1) {
                minHeap.offer(maxHeap.poll());  //放入小根堆
            }
        } else {
            minHeap.offer(num);
            // 保持平衡：小根堆的大小不能超过大根堆的大小
            if (minHeap.size() > maxHeap.size()) {
                maxHeap.offer(minHeap.poll());  // 放入大根堆
            }
        }
    }
    public double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            // 两个堆大小相等，中位数为两个堆顶元素的平均值
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        } else {
            // 大根堆的大小更多，中位数为大根堆的堆顶元素
            return maxHeap.peek();
        }
    }
```
·大根堆存储的是较小的一半元素，堆顶存的是这半部分的最大值。小根堆 存储的是较大的一半元素，堆顶存的是这半部分的最小值。·
每次插入一个新数字时，我们会先将其插入到适当的堆中，然后对堆进行平衡，保证大根堆的元素个数要么比小根堆多一个，要么和小根堆相等。如果大根堆的元素个数超过小根堆，那么我们将大根堆的堆顶元素移到小根堆，反之亦然。
#贪心
```java
// 删除数字
    // 用于标记删除的元素
    Set<Integer> removedElements;
    public void removeNum(int num) {
        // 标记该数字已删除
        removedElements.add(num);
        
        // 对堆进行调整，确保删除的数字被移除
        while (!maxHeap.isEmpty() && removedElements.contains(maxHeap.peek())) {
            maxHeap.poll();
        }
        
        while (!minHeap.isEmpty() && removedElements.contains(minHeap.peek())) {
            minHeap.poll();
        }
        
        // 重新平衡堆
        balanceHeaps();
    }
    // 重新平衡堆
    private void balanceHeaps() {
        // 如果大根堆的元素超过小根堆的元素，则从大根堆移到小根堆
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.offer(maxHeap.poll());
        }
        // 如果小根堆的元素超过大根堆的元素，则从小根堆移到大根堆
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }
```
# 763 划分字母区间
#贪心
```java
public List<Integer> partitionLabels(String s) {
        char[] str = s.toCharArray();
        int n = str.length;
        List<Integer> ans = new ArrayList<>();  // 用来保存分割后的每段子串的长度
        int[] last = new int[26];  // 记录每个字母最后一次出现的位置
        //记录每个字母的最后出现位置
        for (int i = 0; i < n; i++) {
            last[str[i] - 'a'] = i;  // str[i] - 'a' 得到字母 'a' 到 'z' 对应的索引
        }
        int start = 0;  // 当前子字符串的开始位置
        int end = 0;    // 当前子字符串的结束位置
        // 第二遍遍历字符串，确定每个子字符串的划分
        for (int i = 0; i < n; i++) {
            end = Math.max(end, last[str[i] - 'a']);
            // 如果当前字符是子字符串的结束位置，则切割子字符串
            if (end == i) {
                ans.add(end - start + 1);  // 子字符串长度
                start = i + 1;  // 更新子串的起始位置，准备划分下一个子字符串
            }
        }
        return ans;
    }
```
在遍历过程中不断更新当前子字符串的右边界

# 169 多数元素
```java
    public int majorityElement(int[] nums) {
        int x = 0;      // 候选多数元素，初始化为任意值（这里取0）
        int votes = 0;  // 当前候选元素的票数
        // 遍历数组中的每个元素
        for (int num : nums) {
            // 当票数为0时，更换候选元素为当前元素
            if (votes == 0) {
                x = num;
            }
            // 若当前元素等于候选元素，则票数+1，否则票数-1
            votes += (num == x) ? 1 : -1;
        }
        // 最终的候选元素即为多数元素（题目保证存在）
        return x;
    }
```

# 75 颜色分类
```java
    public void sortColors(int[] nums) {
        int p0=0,p1=0;//分别指向0,1的下一个位置
        for(int i=0;i<nums.length;i++){
            int x=nums[i];
            nums[i]=2;
            if(x<=1)
                nums[p1++]=1;
            if(x==0)
                nums[p0++]=0;
        }
    }
```
总体思路：
1.循环中先把位置i赋值为2，然后再根据情况赋值为0或1
2.维护p0,p1的值

# 31 下一个排列
```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n=nums.length;
        int i=n-2;
        while(i>=0 && nums[i]>=nums[i+1])
            i--;
        if(i>=0){
            int j=n-1;
            while(nums[j]<=nums[i])
                j--;
            swap(nums,i,j);
        }
        reverse(nums,i+1,n-1);
    }
    public void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
    public void reverse(int[] nums,int left,int right){
        while(left<right){
            swap(nums,left++,right--);
        }
    }
}
```
1.从后向前查找第一个降序位置：从数组末尾开始，找到第一个索引i，使得nums[i] < nums[i+1]。如果找不到这样的i（即整个数组是降序的），说明当前是最后一个排列，直接跳到最后一步反转整个数组。
2.从后向前查找第一个更大元素：如果找到了i，则在i之后的部分（降序排列）中，从后向前找到第一个索引j，使得nums[j] > nums[i]
3.交换元素：交换nums[i]和nums[j]，此时i之后的部分仍然是降序排列。
4.反转后续元素：将i+1到数组末尾的元素反转，使其变为升序，得到下一个排列

举例：假设输入数组为[1,3,5,4,2]：

1.查找降序位置：从后向前，找到i=1（值为 3），因为3 < 5。
2.查找更大元素：在i之后的部分[5,4,2]中，从后向前找到第一个大于 3 的元素j=3（值为 4）。
3.交换元素：交换i和j，数组变为[1,4,5,3,2]。
4.反转后续元素：反转i+1到末尾的元素[5,3,2]，得到[2,3,5]，最终数组变为[1,4,2,3,5]，即下一个排列。

# 287 寻找重复数
#dp
```java
    public int findDuplicate(int[] nums) {
        int slow=0,fast=0;
        slow=nums[slow];
        fast=nums[nums[fast]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        int pre1 = 0, pre2 = slow;
        while (pre1 != pre2) {
            pre1 = nums[pre1];
            pre2 = nums[pre2];
        }
        return pre1;
    }
```
数组模拟快慢指针，第一个while循环先判断是否有重复数。然后就模拟`环形链表`,从数组点和相遇点同时向前推进。再次相遇即为环的入点。

# 118 杨辉三角
#dp
```java
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> c = new ArrayList<>(numRows);
        c.add(List.of(1));
        for (int i = 1; i < numRows; i++) {
            List<Integer> row = new ArrayList<>(i + 1);
            row.add(1);
            for (int j = 1; j < i; j++)
                row.add(c.get(i - 1).get(j - 1)+c.get(i - 1).get(j));
            row.add(1);
            c.add(row);
        }
        return c;
    }
```
主要学习add()、List.of()、get()用法

# 198 打家劫舍
#dp
```java
    public int rob(int[] nums) {
        int n = nums.length;
        int[] f = new int[n + 2];
        for (int i = 0; i < n; i++) {
            f[i + 2] = Math.max(f[i + 1], f[i] + nums[i]);
        }
        return f[n + 1];
    }
```
声明数组的时候[n+2]

# 279 完全平方数
#dp
```java
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i ++) {
            for (int j = i * i; j <= n; j ++) { //从当前平方数i*i一直到n，尝试更新dp[j]
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);//
            }
        }
        return dp[n];
    }
```
dp[i]表示和为i时所需的最少完全平方数数量
初始化为 Integer.MAX_VALUE 是为了之后可以取 min()
dp[0]代表凑出0不需要任何数

# 322 零钱兑换
#dp
```java
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        Arrays.fill(dp,Integer.MAX_VALUE/2);
        dp[0]=0;
        for(int x:coins){
            for(int c=x;c<=amount;c++)
                dp[c]=Math.min(dp[c],dp[c-x]+1);
        }
        int ans=dp[amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
```
遍历每一个硬币面额x,对于每一个金额c,尝试用当前硬币更新`dp[c]`.
如果我们能用 f[c - x] 构成 c - x，那么 f[c - x] + 1 就是使用当前硬币凑出 c 的方案

# 139 单词划分
#dp
```java
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet=new HashSet<>(wordDict);
        boolean[] dp=new boolean[s.length()+1];
        dp[0]=true;
        for(int i=1;i<=s.length();i++){
            for(int j=0;j<i;j++){
                if(dp[j] && wordSet.contains(s.substring(j,i))){
                    dp[i]=true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
```
`dp[i]`表示字符串s的前i个字符是否可以被字典中的单词拆分
如果`dp[j] == true`，且 `s[j..i-1]` 是一个在字典中的单词，说明前i个字符可以被拆分（即 dp[i] = true）

# 300 最长递增子序列
#dp #贪心
```java
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int[] dp = new int[n];
        Arrays.fill(dp, 1); // 每个元素最短递增子序列至少为1
        int maxLen = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 如果可以接在 nums[j] 之后
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]); // 记录全局最大值
        }
        return maxLen;
    }
```
dp[i]表述以nums[i]结尾的最长递增子序列的长度   

```java
public int lengthOfLIS(int[] nums) {
        List<Integer> tails = new ArrayList<>();
        for (int num : nums) {
            int left = 0, right = tails.size();
            // 二分查找第一个大于等于 num 的位置
            while (left < right) {
                int mid = (left + right) / 2;
                if (tails.get(mid) < num) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            // 替换或添加
            if (left < tails.size()) {
                tails.set(left, num);
            } else {
                tails.add(num);
            }
        }
        return tails.size();
    }
```
tails[]表示当前所有长度为i+1的递增子序列的最小结尾元素   
每来一个数：
- 如果比tails所有元素都大，扩展tails
- 否则用二分法查找替换 tails 中第一个大于等于它的位置，从而维护更小的结尾，有利于构建更长的序列。   
   
10       -> tails: [10]
9        -> tails: [9]           (替换 10)
2        -> tails: [2]           (替换 9)
5        -> tails: [2, 5]
3        -> tails: [2, 3]        (替换 5)
7        -> tails: [2, 3, 7]
101      -> tails: [2, 3, 7, 101]
18       -> tails: [2, 3, 7, 18] (替换 101)   
结果：tails 长度 = 4  

# 152 乘积最大子数组
#dp 
```java
    public int maxProduct(int[] nums) {
        int ans=Integer.MIN_VALUE;
        int curMax=1,curMin=1,preMax=1;
        for(int x:nums){
            preMax=curMax;
            curMax=Math.max(x,Math.max(curMax*x,curMin*x));
            curMin=Math.min(x,Math.min(preMax*x,curMin*x));
            ans=Math.max(curMax,ans);
        }
        return ans;
    }
```
- 分别记录右端点下标为i的子数组的最大乘积以及最小乘积curMax及curMin

# 分割回文串
#回溯 #dp 
```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> ans = new ArrayList<>(); // 存储所有回文分割方案
        List<String> path = new ArrayList<>();      // 当前路径：保存一次回文划分
        int n = s.length();
        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s[i..j]是否是回文子串
        //预处理所有 s[i..j] 是否为回文串
        // 从后往前枚举起点 i，从 i 向后枚举终点 j
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                // s[i..j] 是回文，当且仅当：
                // 首尾字符相等 且 中间部分也是回文（或长度小于等于2）
                dp[i][j] = (s.charAt(i) == s.charAt(j)) && 
			                (j - i < 3 || dp[i + 1][j - 1]);
            }
        }
        //从索引 0 开始进行回溯查找所有方案
        dfs(0, s, path, ans, dp);
        return ans;
    }
    // 回溯函数，从 s[i] 开始划分
    public void dfs(int i, String s, List<String> path, 
				    List<List<String>> ans, boolean[][] dp) {
        if (i == s.length()) {   // 当所有字符都被划分完了，加入到结果集中
            ans.add(new ArrayList<>(path));
            return;
        }
        // 枚举所有可能的回文结束位置 j，从 i 开始
        for (int j = i; j < s.length(); j++) {
            if (dp[i][j]) { // 如果 s[i..j] 是回文串
                path.add(s.substring(i, j + 1)); // 把回文子串加入路径
                dfs(j + 1, s, path, ans, dp);    // 递归处理剩余子串
                path.remove(path.size() - 1);    // 回溯：撤销选择
            }
        }
    }
}
```
substring左闭右开

# 416 分割等和子集
#dp 
```java
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int i:nums)
            sum+=i;
        if(sum%2!=0)
            return false;
        int target=sum/2;
        boolean dp[]=new boolean[target+1];
        dp[0]=true;
        int maxSum=0;//记录当前最大可达的子集和
        for(int num:nums){
            maxSum=Math.min(maxSum+num,target);//更新最大和的边界
            //倒序遍历，避免重复使用同一个num(0-1背包的关键)
            for(int j=maxSum;j>=num;j--)
                dp[j]=dp[j]||dp[j-num];
            if(dp[target])//如果能凑出目标和，则提前返回true
                return true;
        }
        return dp[target];
    }
```
- dp[i]表示是否可以选出若干个数，使他们的和为i
- 先判断总和，如果是奇数则无法划分，之后目标是找到和为sum/2的子集
- 倒序遍历原因：先处理`dp[j]`，然后又马上用已经更新过的 `dp[j]` 去影响后面的 `dp[j + num]`
- maxSum的作用：假设每次都从 `target` 倒序遍历，例如刚开始就算 `num = 1`，我不可能更新 `dp[1000]`。

# 32 最长有效括号
#栈 
```java
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        stack.push(-1);//哨兵
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) {
                    stack.push(i);
                } else {
                    res = Math.max(res, i - stack.peek());
                }
            }
        }
        return res;
    }
```
- 若遇到`(`,索引压栈
- 若遇到`)`,弹出栈顶：
	- 栈为空，说明当前右括号无法匹配，其索引入栈作为新的起点
	- 不为空，计算当前有效字串长度`i-stack.peek()`
- 哨兵用来帮助计算第一个有效字串的长度，也防止第一次遇到`)`弹空时计算失败

# 62 不同路径
#数学 #dp 
```java
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
```

```java
    public int uniquePaths(int m, int n) {
        int[] f = new int[n + 1];
        f[1] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                f[j + 1] += f[j];
            }
        }
        return f[n];
    }
```
带有滚动数组优化的dp解法，原始dp的解法为：
到达 (i,j) 的路径数 = 到达上方 (i-1,j) 的路径数 + 到达左侧 (i,j-1) 的路径数
通过一维数组的复用：`f[j+1] = f[j+1](上方) + f[j](左侧)`

# 64 最小路径和
#dp 
```java
    public int minPathSum(int[][] grid) {
        int m=grid.length,n=grid[0].length;
        int[][] dp=new int [m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0 && j==0)
                    dp[i][j]=grid[i][j];
                else if(i==0)
                    dp[i][j]=dp[i][j-1]+grid[i][j];
                else if(j==0)
                    dp[i][j]=dp[i-1][j]+grid[i][j];
                else
                    dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
```
- 第一行只能从左边来，`dp[0][j] = dp[0][j-1] + grid[0][j]`
- 第一列只能从上面来，`dp[i][0] = dp[i-1][0] + grid[i][0]`
```java
    public int minPathSum(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] dp = new int[n];
        dp[0] = grid[0][0]; // 起点初始化
        // 初始化第一行：只能向右走
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }
        // 从第二行开始逐行更新
        for (int i = 1; i < m; i++) {
            // 第一列只能从上面来
            dp[0] += grid[i][0];
            for (int j = 1; j < n; j++) {
                // 当前格子只能从上面(dp[j])或左边(dp[j-1])来
                dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
            }
        }
        return dp[n - 1]; // 最终值为最后一列的最小路径和
    }

```
`dp[j]`表示当前行第`j`列的最小路径和，当从左网络更新一行时：
- `dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]`
- `dp[j]`表示上一行同列值（上方）
- `dp[j-1]`表示当前行左边值（左侧）

# 最长回文子串
```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0; // 最长回文子串的起始和结束索引
        for (int i = 0; i < s.length(); i++) {
            // 情况1：回文长度为奇数，中心为 i
            int len1 = expandAroundCenter(s, i, i);
            // 情况2：回文长度为偶数，中心为 i 和 i+1
            int len2 = expandAroundCenter(s, i, i + 1);
            // 取两种情况中较长的长度
            int len = Math.max(len1, len2);

            // 如果找到的回文长度比当前记录的更长，则更新起止位置
            if (len > end - start) {
                start = i - (len - 1) / 2; // 计算新的起点
                end = i + len / 2;         // 计算新的终点
            }
        }
        // 返回最长回文子串
        return s.substring(start, end + 1);
    }

    // 中心扩展法，返回以 left 和 right 为中心的最长回文长度
    public int expandAroundCenter(String s, int left, int right) {
        // 向两边扩展，直到不满足回文条件
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 注意：返回的是长度，因此是 right - left - 1
        return right - left - 1;
    }
}

```

# 1143 最长公共子序列
#dp
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // 将 text2 转为字符数组，提高性能
        char[] t = text2.toCharArray();
        int m = t.length;
        // 使用滚动数组，f[j+1] 表示当前状态 dp[i][j]
        int[] f = new int[m + 1];
        for (char x : text1.toCharArray()) {
            int pre = 0; // 代表 f[j] 的上一轮值（即 dp[i-1][j-1]）
            // 遍历 text2 中的每个字符
            for (int j = 0; j < m; j++) {
                int tmp = f[j + 1]; // 当前 f[j+1] 的旧值，即 dp[i-1][j]
                if (x == t[j]) {
                    // 当前字符匹配，更新为 pre + 1（即 dp[i-1][j-1] + 1）
                    f[j + 1] = pre + 1;
                } else {
                    // 不匹配，取左边（dp[i][j-1]）或上边（dp[i-1][j]）最大值
                    f[j + 1] = Math.max(f[j + 1], f[j]);
                }
                pre = tmp;	// 更新 pre 为旧的 f[j+1]，供下次使用
            }
        }
        return f[m];
    }
}

```
| 变量       | 代表含义                               |
| -------- | ---------------------------------- |
| `f[j]`   | 当前行第 j 列左边的值（dp\[i]\[j-1]）         |
| `f[j+1]` | 上一行第 j 列的值（dp\[i-1]\[j]），即“上面”     |
| `pre`    | 上一行第 j-1 列的值（dp\[i-1]\[j-1]），即“左上” |
| `tmp`    | 暂存当前 `f[j+1]` 的旧值，供 `pre = tmp` 用  |

#  79 单词搜索
#回溯 #dfs
```java
class Solution {
    public boolean exist(char[][] board, String word) {
        // 剪枝：若棋盘中字符不足以组成 word，提前返回 false
        if (!canConstruct(board, word)) return false;
        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, word, 0, i, j)) return true;
            }
        }
        return false;
    }
    // DFS 回溯函数：从 board[i][j] 开始，尝试匹配 word[k:]
    private boolean dfs(char[][] board, String word, int k, int i, int j) {
        // 越界或字符不匹配
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(k))
            return false;
        // 匹配到 word 最后一个字符，表示找到了
        if (k == word.length() - 1) 
	        return true;
	        
        // 做标记，防止重复使用该格子
        char tmp = board[i][j];
        board[i][j] = '#';
        boolean found = dfs(board, word, k + 1, i + 1, j)
                     || dfs(board, word, k + 1, i - 1, j)
                     || dfs(board, word, k + 1, i, j + 1)
                     || dfs(board, word, k + 1, i, j - 1);
        // 回溯：恢复现场
        board[i][j] = tmp;
        return found;
    }
    // 字符统计剪枝：如果 word 中有字符在 board 中数量不足，直接返回 false
    private boolean canConstruct(char[][] bo
    ard, String word) {
        int[] freq = new int[128]; // ASCII 范围内即可
        for (char[] row : board)
            for (char c : row) 
	            freq[c]++;
        for (char c : word.toCharArray())
            if (--freq[c] < 0) 
	            return false;
        return true;
    }
}
```
# 72 编辑距离
#dp 
```java
    public int minDistance(String text1, String text2) {
        char[] t = text2.toCharArray();
        int m = t.length;
        // f[j] 表示上一行的 dp[j]，初始为将空串变为text2前 j 个字符的操作次数
        int[] f = new int[m + 1];
        for (int j = 0; j < m; j++) {
            f[j + 1] = j + 1;
        }
        
        for (char x : text1.toCharArray()) {
            int pre = f[0];
            f[0]++;  
            for (int j = 0; j < m; j++) {
                int tmp = f[j + 1];//作为下一轮的“左上角”
                if (x == t[j]) {
                    f[j + 1] = pre;
                } else {
                    f[j + 1] = Math.min(Math.min(f[j + 1], f[j]), pre) + 1;
                }
                pre = tmp; 
            }
        }
        return f[m]; 
    }
```
*核心变量说明（基于滚动数组特性）*：
- `f[j]`：始终存储上一轮（处理 text1 前 i-1 个字符时）的计算结果，即 `dp[i-1][j]`
表示将 text1 前 i-1 个字符转为 text2 前 j 个字符的最少操作数

*循环中变量的动态含义：*
1. 外层循环遍历 text1 每个字符（对应二维 DP 中的 i 从 1 到 len(text1)）
- pre：初始值为 f[0]（`dp[i-1][0]`），随内层循环推进，代表 "上一轮的 f[j]"（`dp[i-1][j]`）
- f[0]++：更新当前轮边界条件 dp[i][0] = i（将 text1 前 i 个字符删为空串需 i 次操作）
 2. 内层循环遍历 text2 每个字符（对应二维 DP 中的 j 从 1 到 len(text2)）
	tmp：缓存更新前的 f[j+1]（即上一轮的 `dp[i-1][j+1]`），用于后续更新 pre
	当字符匹配时（x == t[j]）：
	f[j+1] = pre → 等价于 `dp[i][j+1] = dp[i-1][j]`（无需操作）
	当字符不匹配时：
	f[j+1] = min(上一轮的 f[j+1]（删除）, 当前轮的 f[j]（插入）, pre（替换）) + 1
	pre = tmp → 为下一轮 j 准备 "上一轮的 f[j]"（即 dp[i-1][j+1]）
