# 128 最长连续子序列
`哈希`
```java
for(int x:st){
            if(st.contains(x-1))
                continue;
            y=x+1;
            while(st.contains(y))
                y++;
            ans=Math.max(ans,y-x);
        }
```
以x−1为起点计算出的序列长度，比以x为起点计算出的序列长度要长！避免重复计算

# 283 移动零
`双指针`
```java
        for(i=0,j=0;j<n;j++){
            if(nums[j]!=0){
                swap(nums,i,j);
                i++;
            }
        }
```
# 11 盛最多水的容器
`双指针`
```java
 while(i<=j){
            ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
            if(height[i]<height[j])
                i++;
            else
                j--;
        }
```
若向内移动短板 ，水槽的短板可能变大，因此下个水槽的面积可能增大
若向内移动长板 ，水槽的短板不变或变小，因此下个水槽的面积一定变小
故一定为向内移动短板
# 15 三数之和
`双指针`
```java
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L + 1] == nums[L])
                        L++;
                    while (L < R && nums[R - 1] == nums[R])
                        R--;
                    L++;
                    R--;
                }
```
在while判断之后，L和R记得同步变化。
asList的用法：```java ans.add(Arrays.asList(nums[i], nums[L], nums[R])); ```

# 3 无重复字符的最长子串
`滑动窗口` `哈希`
```java
for(int i=0;i<n;i++){
            if(i!=0)
                fir.remove(s.charAt(i-1));
            while(right+1<n && !fir.contains(s.charAt(right+1))){
                fir.add(s.charAt(right+1));
                right++;
            }
            ans=Math.max(ans,right-i+1);
        }
```
假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk
​。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。

# 438 找到字符串中所有字母异位词
`滑动窗口` `哈希` `字符串`
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n1 = s.length(), n2 = p.length(), differ = 0;
        if (n1 < n2)
            return new ArrayList<Integer>();
        List<Integer> ans = new ArrayList<Integer>();
        //count[]用于记录s和p在窗口内的字符频率差异。>0表示s中该字符比p多，反之同理。
        int[] count = new int[26];
        for (int i = 0; i < n2; i++) {
            count[s.charAt(i) - 'a']++;
            count[p.charAt(i) - 'a']--;
        }
        // 统计初始窗口和 p 的不同字符种类数
        for (int j = 0; j < 26; j++) {
            if (count[j] != 0)
                differ++;
        }
        if (differ == 0)
            ans.add(0);
        //滑动窗口遍历s的剩余部分
        for (int i = 0; i < n1 - n2; i++) {
            //移除窗口左边字符s[i]
            if (count[s.charAt(i) - 'a'] == 1)
                differ--;
            else if (count[s.charAt(i) - 'a'] == 0)
                differ++;
            count[s.charAt(i) - 'a']--;
            //添加窗口右边新字符s[i+n2]
            if (count[s.charAt(i + n2) - 'a'] == -1)
                differ--;
            else if (count[s.charAt(i + n2) - 'a'] == 0)
                differ++;
            count[s.charAt(i+n2) - 'a']++;

            if (differ == 0)
                ans.add(i + 1);
        }
        return ans;
    }
}
```
滑动窗口的核心步骤：

移除窗口左端的字符 s[i]

如果 count[s[i]] == 1，表示 s[i] 在 s 比 p 多 1，删除后 differ--（差异减少）。
如果 count[s[i]] == 0，表示 s[i] 之前是匹配的，删除后 differ++（差异增加）。
更新 count[s[i]]--。
加入窗口右端的新字符 s[i+n2]

如果 count[s[i + n2]] == -1，表示 s[i + n2] 之前是 p 多 1，加入后 differ--（差异减少）。
如果 count[s[i + n2]] == 0，表示 s[i + n2] 之前匹配，加入后 differ++（差异增加）。
更新 count[s[i + n2]]++。
对于count[s[i + n2]] == 1的情况，则说明只有s[i + n2]之前刚好匹配 p，加入后才会 0 -> 1，但这种情况在滑动窗口过程中并不会影响 differ 计算的正确性

# 560 和为k的子数组
`前缀和` `哈希`
```java
//创建哈希表后需要添加元素(0,1),表示前缀和0出现过一次。
hashmap.getOrDefault(Object key, V defaultValue) //获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
hashmap.get(Object key) //获取指定 key 对应对 value
for(int i=0;i<n;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k))
                count+=map.get(pre-k);
            map.put(pre,map.getOrDefault(pre,0)+1);
        }
```
# 42 接雨水
`双指针`
```java
while(l<r){
            pre=Math.max(pre,height[l]);
            tail=Math.max(tail,height[r]);
            if(pre<tail){
                ans+=pre-height[l];
                l++;
            }
            else{
                ans+=tail-height[r];
                r--;
            }
        }
```
声明左右指针l,r;前缀后缀pre,tail.
遍历，依次求出pre、tail的最大值。
如果pre<tail,当前格能接的雨水则为pre-height[l],左指针右移
如果pre>=tail,当前格能接的雨水则为tail-height[r]，右指针左移

# 239 滑动窗口最大值
`单调队列` `滑动窗口`
```java
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            //1.头：清理超期元素
            if (!deque.isEmpty() && deque.peek() == i - k) {
                deque.remove();
            }
            //2.尾：维护单调队列递减性，删除所有比新入队元素小的旧元素
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.removeLast();
            }
            //3.尾：新元素入队
            deque.add(i);
            //4.头：获取滑动窗口内最大值
            if(i>=k-1){
                ans[ansIndex] = nums[deque.peek()];
                ansIndex++;
            }
        }
```
创建双端队列后分成四部分来做(头尾尾头)，双端队列里面放的是**下标**
1.头：清理超期元素，即i-k位置的元素
滑动窗口的左边界始终是i-k+1，若deque.peek()==i-k,说明已经不在窗口[i-k,i]中
2.尾：维护单调队列递减性，删除所有比新入队元素小的旧元素
3.尾：新元素入队
4.头：获取滑动窗口内最大值
判断 **if(i>=k-1)** 是为了确保窗口已经形成，否则ans[ansIndex]可能越界。
比如i=k-1=2时，窗口[0,2]首次达到窗口值3,i<k-1时记录最大值没有意义

# 53 最大子数组和
`dp` `前缀和` 
```java
//法一：前缀和
for(int x:nums) {
            pre += x;
            ans = Math.max(ans, pre - minPre);
            minPre = Math.min(pre, minPre);
        }
```
先计算完ans再去更新minPre。
```java
//法二：dp
 for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
```
动态转移方程 f(i)=max{f(i−1)+nums[i],nums[i]}
```java
//法三：线段树(尚未学习)
```

# 56 合并区间
`排序`
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (p, q) -> p[0] - q[0]); // 按照左端点从小到大排序
        List<int[]> ans = new ArrayList<>();
        for (int[] p : intervals) {
            int m = ans.size();
            if (m > 0 && p[0] <= ans.get(m - 1)[1]) { // 可以合并
                ans.get(m - 1)[1] = Math.max(ans.get(m - 1)[1], p[1]); // 更新右端点最大值
            } else { // 不相交，无法合并
                ans.add(p); // 新的合并区间
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

# 41 缺失的第一个正数
`哈希`
```java
public int firstMissingPositive(int[] nums) {
    int len = nums.length;
    
    // 第一轮：把所有正整数放到正确的位置
    for (int i = 0; i < len; i++) {
        while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
            // 交换 nums[i] 到它正确的位置 nums[nums[i] - 1]
            swap(nums, nums[i] - 1, i);
        }
    }

    // 第二轮：找出第一个不符合 nums[i] == i + 1 的位置
    for (int i = 0; i < len; i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    // 如果所有元素都正确，则返回 len + 1
    return len + 1;
}
```
1.由于缺失的最小正数一定在[1,len+1],故要通过交换元素调整数组中索引和值对应的状态，即nums[i]==i+1
交换的条件是：
- nums[i]为正数
- nums[i]不超过数组的长度
- nums[i]没有被放在正确的位置上nums[nums[i]-1]!=nums[i]
2.找出第一个不符合nums[i]==i+1的索引i，i+1就是缺失的最小正数
3.若数组已符合要求，则返回len+1

# 76 最小覆盖字串
`滑动窗口` `哈希`
```java
import java.util.*;

class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return ""; // 边界情况：s 或 t 为空

        Map<Character, Integer> mapt = new HashMap<>(); // 统计 t 中每个字符的频次
        Map<Character, Integer> mapw = new HashMap<>(); // 记录窗口内字符的频次
        for (char c : t.toCharArray()) {
            mapt.put(c, mapt.getOrDefault(c, 0) + 1);
        }
        // 过滤 s 中无关字符，并存储 (字符, 原索引)
        List<int[]> filteredS = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (mapt.containsKey(c)) {
                filteredS.add(new int[]{c, i}); // 只保留 t 需要的字符
            }
        }
        int required = mapt.size(); // 需要满足的不同字符种类数
        int formed = 0; // 记录当前窗口满足条件的字符种类数
        int l = 0, r = 0; // 双指针窗口
        int minLen = Integer.MAX_VALUE, ansL = -1, ansR = -1; // 记录最小窗口
        // 进行滑动窗口搜索
        while (r < filteredS.size()) {
            char c = (char) filteredS.get(r)[0]; // 获取右指针的字符
            mapw.put(c, mapw.getOrDefault(c, 0) + 1);
            // 如果窗口中的 c 字符达到了 t 的要求，更新 formed
            if (mapw.get(c).equals(mapt.get(c)))    formed++;
            // 当窗口满足所有 t 中字符的要求时，开始收缩左边界
            while (formed == required) {
                char leftChar = (char) filteredS.get(l)[0]; // 获取左指针的字符
                int start = filteredS.get(l)[1]; // 获取左边界字符的原索引
                int end = filteredS.get(r)[1]; // 获取右边界字符的原索引
                // 记录当前最小窗口
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    ansL = start;
                    ansR = end + 1;
                }
                // 移除左边界字符
                mapw.put(leftChar, mapw.get(leftChar) - 1);
                if (mapw.get(leftChar) < mapt.get(leftChar)) {
                    formed--; // 如果移除的字符频次低于 t 需要的数量，则窗口不再满足条件
                }
                l++; // 移动左指针
            }
            r++; // 扩展右指针
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR); // 返回最小窗口子串
    }
}

```
## 预处理s，使其只保留t中的字符及索引
- 预处理s，找到所有属于t的字符及索引，存入filteredS，这样之后只需要在filteredS上操作
- 这样之后只需要在filteredS上操作滑动窗口




