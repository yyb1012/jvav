# 128 最长连续子序列
`哈希`
```java
for(int x:st){
            if(st.contains(x-1))
                continue;
            y=x+1;
            while(st.contains(y))
                y++;
            ans=Math.max(ans,y-x);
        }
```
以x−1为起点计算出的序列长度，比以x为起点计算出的序列长度要长！避免重复计算

# 283 移动零
`双指针`
```java
        for(i=0,j=0;j<n;j++){
            if(nums[j]!=0){
                swap(nums,i,j);
                i++;
            }
        }
```
# 11 盛最多水的容器
`双指针`
```java
 while(i<=j){
            ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
            if(height[i]<height[j])
                i++;
            else
                j--;
        }
```
若向内移动短板 ，水槽的短板可能变大，因此下个水槽的面积可能增大
若向内移动长板 ，水槽的短板不变或变小，因此下个水槽的面积一定变小
故一定为向内移动短板
# 15 三数之和
`双指针`
```java
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L + 1] == nums[L])
                        L++;
                    while (L < R && nums[R - 1] == nums[R])
                        R--;
                    L++;
                    R--;
                }
```
在while判断之后，L和R记得同步变化。
asList的用法：```java ans.add(Arrays.asList(nums[i], nums[L], nums[R])); ```

# 3 无重复字符的最长子串
`滑动窗口` `哈希`
```java
for(int i=0;i<n;i++){
            if(i!=0)
                fir.remove(s.charAt(i-1));
            while(right+1<n && !fir.contains(s.charAt(right+1))){
                fir.add(s.charAt(right+1));
                right++;
            }
            ans=Math.max(ans,right-i+1);
        }
```
假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk
​。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。


