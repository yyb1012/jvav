# 128 最长连续序列
`哈希`
`找出无序数组中数字连续的最长序列`
```java
//input:[100,4,200,1,3,2]  OUPUT:[1,2,3,4]长度为4
for(int x:st){
            if(st.contains(x-1))
                continue;
            y=x+1;
            while(st.contains(y))
                y++;
            ans=Math.max(ans,y-x);
        }
```
以x−1为起点计算出的序列长度，比以x为起点计算出的序列长度要长！避免重复计算

# 283 移动零
`双指针`
`将数组中所有的0移动到数组的末尾`
```java
        for(i=0,j=0;j<n;j++){
            if(nums[j]!=0){
                swap(nums,i,j);
                i++;
            }
        }
```
# 11 盛最多水的容器
`双指针`
```java
 while(i<=j){
            ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
            if(height[i]<height[j])
                i++;
            else
                j--;
        }
```
若向内移动短板 ，水槽的短板可能变大，因此下个水槽的面积可能增大
若向内移动长板 ，水槽的短板不变或变小，因此下个水槽的面积一定变小
故一定为向内移动短板
# 15 三数之和
`双指针`
```java
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L + 1] == nums[L])
                        L++;
                    while (L < R && nums[R - 1] == nums[R])
                        R--;
                    L++;
                    R--;
                }
```
在while判断之后，L和R记得同步变化。
asList的用法：```java ans.add(Arrays.asList(nums[i], nums[L], nums[R])); ```

# 3 无重复字符的最长子串
`滑动窗口` `哈希`
`给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度`
```java
for(int i=0;i<n;i++){
            if(i!=0)
                fir.remove(s.charAt(i-1));
            while(right+1<n && !fir.contains(s.charAt(right+1))){
                fir.add(s.charAt(right+1));
                right++;
            }
            ans=Math.max(ans,right-i+1);
        }
```
假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk
​。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。

# 438 找到字符串中所有字母异位词
`滑动窗口` `哈希` `字符串`
`给定两个字串s和p，找出s中所有p的异位词(相同字母但是不同顺序)的字串，返回字串起始索引`
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n1 = s.length(), n2 = p.length(), differ = 0;
        if (n1 < n2)
            return new ArrayList<Integer>();
        List<Integer> ans = new ArrayList<Integer>();
        //count[]用于记录s和p在窗口内的字符频率差异。>0表示s中该字符比p多，反之同理。
        int[] count = new int[26];
        for (int i = 0; i < n2; i++) {
            count[s.charAt(i) - 'a']++;
            count[p.charAt(i) - 'a']--;
        }
        // 统计初始窗口和 p 的不同字符种类数
        for (int j = 0; j < 26; j++) {
            if (count[j] != 0)
                differ++;
        }
        if (differ == 0)
            ans.add(0);
        //滑动窗口遍历s的剩余部分
        for (int i = 0; i < n1 - n2; i++) {
            //移除窗口左边字符s[i]
            if (count[s.charAt(i) - 'a'] == 1)
                differ--;
            else if (count[s.charAt(i) - 'a'] == 0)
                differ++;
            count[s.charAt(i) - 'a']--;
            //添加窗口右边新字符s[i+n2]
            if (count[s.charAt(i + n2) - 'a'] == -1)
                differ--;
            else if (count[s.charAt(i + n2) - 'a'] == 0)
                differ++;
            count[s.charAt(i+n2) - 'a']++;

            if (differ == 0)
                ans.add(i + 1);
        }
        return ans;
    }
}
```
滑动窗口的核心步骤：

移除窗口左端的字符 s[i]

如果`count[s[i]] == 1`，表示 s[i] 在 s 比 p 多 1，删除后`differ--`（差异减少）。
如果`count[s[i]] == 0`，表示 s[i] 之前是匹配的，删除后`differ++`（差异增加）。
更新`count[s[i]]--`。
加入窗口右端的新字符 `s[i+n2]`

如果 `count[s[i + n2]] == -1`，表示 `s[i + n2]` 之前是 p 多 1，加入后 `differ--`（差异减少）。
如果 `count[s[i + n2]] == 0`，表示 `s[i + n2]` 之前匹配，加入后 `differ++`（差异增加）。
更新 `count[s[i + n2]]++`。
对于`count[s[i + n2]] == 1`的情况，则说明只有`s[i + n2]`之前刚好匹配 p，加入后才会 0 -> 1，但这种情况在滑动窗口过程中并不会影响 differ 计算的正确性

# 560 和为k的子数组
`前缀和` `哈希`
```java
//创建哈希表后需要添加元素(0,1),表示前缀和0出现过一次。
hashmap.getOrDefault(Object key, V defaultValue) //获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值
hashmap.get(Object key) //获取指定 key 对应对 value
for(int i=0;i<n;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k))
                count+=map.get(pre-k);
            map.put(pre,map.getOrDefault(pre,0)+1);
        }
```
# 42 接雨水
`双指针`
```java
while(l<r){
            pre=Math.max(pre,height[l]);
            tail=Math.max(tail,height[r]);
            if(pre<tail){
                ans+=pre-height[l];
                l++;
            }
            else{
                ans+=tail-height[r];
                r--;
            }
        }
```
声明左右指针l,r;前缀后缀pre,tail.
遍历，依次求出pre、tail的最大值。
如果pre<tail,当前格能接的雨水则为pre-height[l],左指针右移
如果pre>=tail,当前格能接的雨水则为tail-height[r]，右指针左移

# 239 滑动窗口最大值
`单调队列` `滑动窗口`
```java
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            //1.头：清理超期元素
            if (!deque.isEmpty() && deque.peek() == i - k) {
                deque.remove();
            }
            //2.尾：维护单调队列递减性，删除所有比新入队元素小的旧元素
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.removeLast();
            }
            //3.尾：新元素入队
            deque.add(i);
            //4.头：获取滑动窗口内最大值
            if(i>=k-1){
                ans[ansIndex] = nums[deque.peek()];
                ansIndex++;
            }
        }
```
创建双端队列后分成四部分来做(头尾尾头)，双端队列里面放的是**下标**
1.头：清理超期元素，即i-k位置的元素
滑动窗口的左边界始终是i-k+1，若deque.peek()==i-k,说明已经不在窗口[i-k,i]中
2.尾：维护单调队列递减性，删除所有比新入队元素小的旧元素
3.尾：新元素入队
4.头：获取滑动窗口内最大值
判断 **if(i>=k-1)** 是为了确保窗口已经形成，否则ans[ansIndex]可能越界。
比如i=k-1=2时，窗口[0,2]首次达到窗口值3,i<k-1时记录最大值没有意义

# 53 最大子数组和
`dp` `前缀和` 
```java
//法一：前缀和
for(int x:nums) {
            pre += x;
            ans = Math.max(ans, pre - minPre);
            minPre = Math.min(pre, minPre);
        }
```
先计算完ans再去更新minPre。
```java
//法二：dp
 for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
```
动态转移方程 f(i)=max{f(i−1)+nums[i],nums[i]}
```java
//法三：线段树(尚未学习)
```

# 56 合并区间
`排序`
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (p, q) -> p[0] - q[0]); // 按照左端点从小到大排序
        List<int[]> ans = new ArrayList<>();
        for (int[] p : intervals) {
            int m = ans.size();
            if (m > 0 && p[0] <= ans.get(m - 1)[1]) { // 可以合并
                ans.get(m - 1)[1] = Math.max(ans.get(m - 1)[1], p[1]); // 更新右端点最大值
            } else { // 不相交，无法合并
                ans.add(p); // 新的合并区间
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

# 41 缺失的第一个正数
`哈希`
```java
public int firstMissingPositive(int[] nums) {
    int len = nums.length;
    
    // 第一轮：把所有正整数放到正确的位置
    for (int i = 0; i < len; i++) {
        while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
            // 交换 nums[i] 到它正确的位置 nums[nums[i] - 1]
            swap(nums, nums[i] - 1, i);
        }
    }

    // 第二轮：找出第一个不符合 nums[i] == i + 1 的位置
    for (int i = 0; i < len; i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    // 如果所有元素都正确，则返回 len + 1
    return len + 1;
}
```
1.由于缺失的最小正数一定在[1,len+1],故要通过交换元素调整数组中索引和值对应的状态，即nums[i]==i+1
交换的条件是：
- nums[i]为正数
- nums[i]不超过数组的长度
- nums[i]没有被放在正确的位置上nums[nums[i]-1]!=nums[i]
2.找出第一个不符合nums[i]==i+1的索引i，i+1就是缺失的最小正数
3.若数组已符合要求，则返回len+1

# 76 最小覆盖字串
`滑动窗口` `哈希`
```java
import java.util.*;

class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return ""; // 边界情况：s 或 t 为空

        Map<Character, Integer> mapt = new HashMap<>(); // 统计 t 中每个字符的频次
        Map<Character, Integer> mapw = new HashMap<>(); // 记录窗口内字符的频次
        for (char c : t.toCharArray()) {
            mapt.put(c, mapt.getOrDefault(c, 0) + 1);
        }
        // 过滤 s 中无关字符，并存储 (字符, 原索引)
        List<int[]> filteredS = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (mapt.containsKey(c)) {
                filteredS.add(new int[]{c, i}); // 只保留 t 需要的字符
            }
        }
        int required = mapt.size(); // 需要满足的不同字符种类数
        int formed = 0; // 记录当前窗口满足条件的字符种类数
        int l = 0, r = 0; // 双指针窗口
        int minLen = Integer.MAX_VALUE, ansL = -1, ansR = -1; // 记录最小窗口
        // 进行滑动窗口搜索
        while (r < filteredS.size()) {
            char c = (char) filteredS.get(r)[0]; // 获取右指针的字符
            mapw.put(c, mapw.getOrDefault(c, 0) + 1);
            // 如果窗口中的 c 字符达到了 t 的要求，更新 formed
            if (mapw.get(c).equals(mapt.get(c)))    formed++;
            // 当窗口满足所有 t 中字符的要求时，开始收缩左边界
            while (formed == required) {
                char leftChar = (char) filteredS.get(l)[0]; // 获取左指针的字符
                int start = filteredS.get(l)[1]; // 获取左边界字符的原索引
                int end = filteredS.get(r)[1]; // 获取右边界字符的原索引
                // 记录当前最小窗口
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    ansL = start;
                    ansR = end + 1;
                }
                // 移除左边界字符
                mapw.put(leftChar, mapw.get(leftChar) - 1);
                if (mapw.get(leftChar) < mapt.get(leftChar)) {
                    formed--; // 如果移除的字符频次低于 t 需要的数量，则窗口不再满足条件
                }
                l++; // 移动左指针
            }
            r++; // 扩展右指针
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR); // 返回最小窗口子串
    }
}

```
## 预处理s，使其只保留t中的字符及索引
- 预处理s，找到所有属于t的字符及索引，存入filteredS，这样之后只需要在filteredS上操作
- 这样之后只需要在filteredS上操作滑动窗口

# 73 矩阵置0
`哈希` `矩阵`
```java
for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                flagCol0 = true;//记录第一列是否有0
            }
            for (int j = 1; j < n; j++)  {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;//第一行和第一列作为标记
                }
            }
        }
        //根据标记置0
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (flagCol0) {
                matrix[i][0] = 0;//处理第一列
            }
        }
```
- 原地处理，使用第一行和第一列作为标记
# 54 螺旋矩阵
`矩阵`
```java
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            //步骤1
            for (int column = left; column <= right; column++) {
                order.add(matrix[top][column]);
            }
            //步骤2
            for (int row = top + 1; row <= bottom; row++) {
                order.add(matrix[row][right]);
            }
            if (left < right && top < bottom) {
               //步骤3
                for (int column = right - 1; column > left; column--) {
                    order.add(matrix[bottom][column]);
                }
               //步骤4
                for (int row = bottom; row > top; row--) {
                    order.add(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
```
首先输出最外层的元素，然后输出最内层的元素（具体+1/-1可以改变，主要是思想）
- 从左到右遍历上侧元素:(top,left) -> (top,right)
- 从上到下遍历右侧元素:(top+1,right) -> (bottom,tight)
- 从右到左遍历底层元素:(bottom,right-1）-> (bottom,left+1)
- 从下到上遍历左侧元素:(bottom,left) -> (top+1,left)

步骤3和步骤4需要再次判断，避免在只有一行或一列的情况下重复访问

# 48 旋转图像
`矩阵`
```java
public void rotate(int[][] matrix) {
    int n = matrix.length;  // 矩阵大小 N×N
    for (int i = 0; i < n / 2; ++i) {   // 遍历上半部分
        for (int j = 0; j < (n + 1) / 2; ++j) {  // 遍历左半部分
            int temp = matrix[i][j];  // 存储左上角的元素

            // 顺时针旋转 4 个元素
            matrix[i][j] = matrix[n - j - 1][i];  
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];  
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];  
            matrix[j][n - i - 1] = temp;  
        }
    }
}
```
主要思路就是顺时针旋转4个元素，记住顺序
然后记住遍历的顺序，i=n/2,j<(n+1)/2

# 4 寻找两个正序数组的中位数
`分治` `二分`
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        int m = nums1.length;
        int n = nums2.length;
        int left = 0, right = m;

        int median1 = 0, median2 = 0;

        while (left <= right) {
            int i = (left + right) / 2;
            int j = (m + n + 1) / 2 - i;

            int nums_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]);
            int nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]);
            int nums_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]);
            int nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]);

            if (nums_im1 <= nums_j) {
                median1 = Math.max(nums_im1, nums_jm1);
                median2 = Math.min(nums_i, nums_j);
                left = i + 1;
            } else {
                right = i - 1;
            }
        }
        return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
    }
}
```
- 核心思想是分别将两个数组分为左右两部分，`max(nums1[i-1], nums2[j-1]) <= min(nums1[i], nums2[j])`
代表已经找到了正确的位置，即i、j代表的位置将数组分割为了正确的左右两部分。
- 假设前部分取了`nums1`的前`i`个元素，`nums2`的前`j`个元素，那么i+j=(m+n+1)/2
- `nums_im1` `nums_jm1`代表前半部分的最大值(最后一个数)， `nums_i` `nums_j`代表后半部分的最小值(第一个)。
i==0说明nums1没有左半部分，nums_im1设置为最小值；i==m说明nums1没有右半部分，设置为最大值
- 如果 nums_im1 <= nums_j，说明 i 是合适的分割点，更新 median1 和 median2。否则说明i取大了，right=i-1

# 240 搜索二维矩阵Ⅱ
`二分` `分治`
```java
int m=matrix.length,n=matrix[0].length;
        int x=0,y=n-1;
        while(x<m && y>=0){
            if(matrix[x][y]==target)
                return true;
            else if(matrix[x][y]<target)
                x++;
            else if(matrix[x][y]>target)
                y--;
        }
```
从右上角开始遍历

# 160相交链表，206反转链表，21 合并有序链表
```java
//相交矩阵，返回相交的起始节点
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        while (p != q) {
            p = p != null ? p.next : headB;
            q = q != null ? q.next : headA;
        }
        return p;
    }
```
x为链表A不同的距离，y为链表B不同的距离，z为共同的距离：(x+z)+y=(y+z)+x
每次循环，p 和 q 各向后走一步。如果 p 非空，那么更新 p 为 p.next，否则更新 p 为 headB；如果 q非空，那么更新 q 为 q.next，否则更新 q 为 headA。

```java
//反转链表 迭代法，头插法
    public ListNode reverseList(ListNode head) {
        ListNode cur=head,prev=null;
        while(cur!=null){
            ListNode next=cur.next;
            cur.next=prev;
            prev=cur;
            cur=next;
        }
        return prev;
    }
```
要交换的对象只有pre和cur指针，next指针只是一个锚点。
在考虑这道题的时候，不要像之前一样考虑头插的过程，只需要考虑把箭头反转就可以。

```java
//合并链表
        ListNode list=new ListNode(-1);
        ListNode prev=list;
        while(list1!=null && list2!=null){
            if(list1.val<=list2.val){
                prev.next=list1;
                list1=list1.next;
            }
            else{
                prev.next=list2;
                list2=list2.next;
            }
            prev=prev.next;
        }
        prev.next=list1==null?list2:list1;
        return list.next;
```
创建新节点val为-1，再用另一个指针进行操作。

# 142 环形链表
`双指针`
```java
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
```
假设环外的长度为a，slow入环之后又走了b与fast相遇，c为环中剩余的距离。此时fast指针已经走完了n圈，故其走过的总距离为a+n(b+c)+b=a+(n+1)b+nc.
fast距离为slow的2倍，故a+(n+1)b+nc=2(a+b),可得a=c+(n-1)(b+c)
即从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。
使用指针ptr指向head，在快慢指针相遇之后与slow同时向前移动，最终会在入环点相遇

# 2 两数相加
```java
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;//进位值
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null)
                l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
        }
        if (carry > 0)
            tail.next = new ListNode(carry);
        return head;
    }
```
链表中对应位置的值为`(n1+n2+carry) mod 10`,新的进位值为`(n1+n2+carry) / 10`
如果链表遍历结束后，有carry>0，还需要在答案链表的后面附加一个节点，节点的值为carry。

```java
    public ListNode swapPairs(ListNode head) {
        ListNode tmp = new ListNode(0,head);
        ListNode node0=tmp,node1=head;
        while(node1!=null && node1.next!=null){
            ListNode node2=node1.next;
            ListNode node3=node2.next;

            node0.next=node2;
            node2.next=node1;
            node1.next=node3;

            node0=node1;
            node1=node3;
        }
        return tmp.next;
    }
```
假设有序列`[0,1,2,3,4,5]`,node的序号代表最开始指向了哪个值。
0作为哨兵，先把0指向2，2指向1，1指向3。此时顺序为`[0,2,1,3]`,此时1就是上一步的node0的作用。

# 25 k个一组翻转链表
```java
    public ListNode reverseKGroup(ListNode head, int k) {
        int n=0;
        for(ListNode cur=head;cur!=null;cur=cur.next)
            n++;
        ListNode tmp=new ListNode(0,head);
        ListNode p0=tmp,pre=null,cur=head;
        for(;n>=k;n-=k){
            for(int i=0;i<k;i++){
                ListNode nxt=cur.next;
                cur.next=pre;
                pre=cur;
                cur=nxt;
            }
            
            ListNode nxt=p0.next;
            p0.next.next=cur;
            p0.next=pre;
            p0=nxt;
        }
        return tmp.next;
    }
```
![image](https://github.com/user-attachments/assets/39dd5be5-4584-4a47-9d57-78e8bd956a98)
p0.next.next指向cur，p0.next指向pre.

# 138 随机链表的复制
```java
public Node copyRandomList(Node head) {
        if (head == null)
            return null;

        //遍历中复制每一个节点, 并把新节点插在原节点的后面
        for (Node cur = head; cur != null; cur = cur.next.next)
            cur.next = new Node(cur.val, cur.next);

        //遍历链表,解决random指针
        for (Node cur = head; cur != null; cur = cur.next.next) {
            if (cur.random != null)
                //cur.random的next节点即为random节点的复制节点
                cur.next.random = cur.random.next;
        }

        //将新链表分离出来
        Node newHead = head.next;
        Node cur = head;
        for (; cur.next.next != null; cur = cur.next) {
            Node tmp = cur.next; //指向第一个新节点
            cur.next = tmp.next; //老节点指针指向下一个老节点，也就是tmp.next
            tmp.next = tmp.next.next; //新节点指向下一个新节点
        }
        cur.next = null;//遍历到最后一个老节点，指向null
        return newHead;
    }
```
需要注意的是两次遍历cur=cur.next.next,重点理解random指针部分和最后的分离部分
$$1\longrightarrow1^{'}\longrightarrow2\longrightarrow2^{'}\longrightarrow3\longrightarrow3^{'}$$

# 23 合并k个升序链表
`优先队列` `最小堆` `分治`
```java
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
        for (ListNode head : lists) {
            if (head != null)
                pq.offer(head); // 把所有非空链表的头节点入堆
        }

        ListNode Sentinel = new ListNode();
        ListNode cur = Sentinel;
        while (!pq.isEmpty()) {//循环直至堆为空
            ListNode node = pq.poll();//最小节点
            if (node.next != null)
                pq.offer(node.next);//下一个节点有可能为最小节点，入堆

            cur.next = node;//把node添加到新节点的末尾
            cur = cur.next;//准备合并下一个节点
        }
        return Sentinel.next;
    }
```
最小堆做法：初始把所有链表头节点入堆，然后不断弹出堆中最小节点x，如果x.next不为空就加入堆中，把弹出的节点按顺序拼接。实现时，可以用哨兵节点Sentinel简化代码。
时间复杂度为O(nlogk)，空间复杂度为O(k)

```java
public ListNode mergeKLists(ListNode[] lists) {
        return mergeKLists(lists, 0, lists.length);
    }

    // 合并从 lists[i] 到 lists[j-1] 的链表
    private ListNode mergeKLists(ListNode[] lists, int i, int j) {
        int m = j - i;
        if (m == 0) {
            return null; // 注意输入的 lists 可能是空的
        }
        if (m == 1) {
            return lists[i]; // 无需合并，直接返回
        }
        ListNode left = mergeKLists(lists, i, i + m / 2); // 合并左半部分
        ListNode right = mergeKLists(lists, i + m / 2, j); // 合并右半部分
        return mergeTwoLists(left, right); // 最后把左半和右半合并
    }

    // 21. 合并两个有序链表
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(); // 用哨兵节点简化代码逻辑
        ListNode cur = dummy; // cur 指向新链表的末尾
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1; // 把 list1 加到新链表中
                list1 = list1.next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur.next = list2; // 把 list2 加到新链表中
                list2 = list2.next;
            }
            cur = cur.next;
        }
        cur.next = list1 != null ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }
```
时间复杂度为O(nlogk)，空间复杂度为O(logk)

# 148 排序链表
`归并`
```java
    public ListNode sortList(ListNode head) {
        if(head==null || head.next==null)
            return head;
        
        //找到链表中点
        ListNode slow=head,fast=head.next;
        while(fast!=null && fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
        }

        //拆分链表为两半,[head,slow],[slow.next,end]
        ListNode mid=slow.next;//右半半部分起点
        slow.next=null;//断开链表

        ListNode left=sortList(head);
        ListNode right=sortList(mid);

        return merge(left,right);
    }
    private ListNode merge(ListNode l1,ListNode l2){
        ListNode Sentinel =new ListNode(0);
        ListNode cur=Sentinel;
        //双指针遍历两个链表，合并
        while(l1!=null && l2!=null){
            if(l1.val<l2.val){
                cur.next=l1;
                l1=l1.next;
            }
            else{
                cur.next=l2;
                l2=l2.next;
            }
            cur=cur.next;
        }
        cur.next=(l1!=null)?l1:l2;
        return Sentinel.next;
    }
```
核心思想，先通过快慢指针找到链表的中点，然后把链表断为左右两部分。
归并过程就是通过双指针，依次比较值的大小。

# 146 LRU缓存
```java
    private final int capacity;
    private final Node Sentinel = new Node(0, 0);
    private final Map<Integer, Node> keyToNode = new HashMap<>();

    private static class Node {
        int key, value;
        Node prev, next;
        Node(int k, int v) {
            this.key = k;
            this.value = v;
        }
    }

    public LRUCache(int capacity) {
        this.capacity = capacity;
        Sentinel.next = Sentinel;
        Sentinel.prev = Sentinel;
    }

    public int get(int key) {
        Node node = getNode(key);
        return node != null ? node.value : -1;
    }

    public void put(int key, int value) {
        Node node = getNode(key);
        if (node != null) {
            node.value = value;
            return;
        }
        node = new Node(key, value);
        keyToNode.put(key, node);
        pushFront(node);
        if (keyToNode.size() > capacity) {
            Node backNode = Sentinel.prev;
            keyToNode.remove(backNode.key);
            remove(backNode);
        }
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    private Node getNode(int key) {
        if (!keyToNode.containsKey(key))
            return null;
        Node node = keyToNode.get(key);
        remove(node);
        pushFront(node);
        return node;
    }

    // 删除一个节点
    private void remove(Node n) {
        n.prev.next = n.next;
        n.next.prev = n.prev;
    }

    // 在链表头添加一个节点
    private void pushFront(Node n) {
        n.prev = Sentinel;
        n.next = Sentinel.next;
        n.prev.next = n;
        n.next.prev = n;
    }
```
`get(int key)`:查找key，把对应系欸但移动到链表头(表示刚使用过)
`put(int key,int value)`:取出key对应的节点并移到头部，存在则更新值，不存在则创建。超出容量移除链表尾
`getNode(int key)`:找到key对应的节点，先从原位置移除再放到表头

# 226 翻转二叉树  101 对称二叉树  543 二叉树的直径
`递归`
```java
TreeNode left=invertTree(root.left);
TreeNode right=invertTree(root.right);
root.left=right;
root.right=left;
return root;
```
```java
public boolean check(TreeNode p,TreeNode q){
        if(p==null && q==null)
            return true;
        if(p==null || q==null)
            return false;
        return p.val==q.val && check(p.left,q.right) && check(p.right,q.left);
    }
```
```java
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return ans;
    }
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        ans = Math.max(left + right, ans);
        return Math.max(left, right) + 1;
    }
```
`return`语句+1：在计算当前节点的最大深度时，要算上自己这一层

# 102 二叉树层序遍历
```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        //用于存放每一层的节点值
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        if (root != null)
            queue.add(root);
        while (!queue.isEmpty()) {
            //当前队列节点数，即当前层的节点数
            int n = queue.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            ans.add(level);
        }
        return ans;
    }
```

```java
    public List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return result;
        bfs(root,0);
        return result;
    }

    public void bfs(TreeNode root, int height){
        if(root == null) return;
        // 如果结果列表中还没有当前层的子列表，则创建一个新的子列表并加入结果列表
        if(result.size() <= height){
            List<Integer> temp = new ArrayList<Integer>();
            result.add(temp);
        }
        // 获取当前深度对应的子列表
        List<Integer> temp = result.get(height);
        // 将当前节点的值加入当前层的子列表
        temp.add(root.val);

        bfs(root.left, height+1);
        bfs(root.right, height+1);
    }
```
# 108 有序数组转化为二叉搜索树
```java
    public TreeNode sortedArrayToBST(int[] nums) {
        return devide(nums, 0, nums.length - 1);
    }
    public TreeNode devide(int[] nums, int left, int right) {
        if (left > right)
            return null;
        int mid = (left + right) >> 1;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = devide(nums, left, mid - 1);
        root.right = devide(nums, mid + 1, right);
        return root;
    }
```

# 98 验证二叉搜索树
```java
    //用来记录 中序遍历中“前一个节点”的值；
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null)
            return true;
        if (!isValidBST(root.left) || root.val <= pre)
            return false;
        pre = root.val;
        return isValidBST(root.right);
    }
```
# 230 二叉搜索树第k小的元素
```java
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        return dfs(root);
    }
    private int dfs(TreeNode Node) {
        if (Node == null)
            return -1;
        int left = dfs(Node.left);
        if (left != -1)
            return left;
        if (--k == 0)//每处理一个节点，k-1
            return Node.val;
        return dfs(Node.right);
    }
```
中序遍历

# 199 二叉树的右视图
```java
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans= new ArrayList<>();
        dfs(root,0,ans);
        return ans;
    }
    private void dfs(TreeNode root,int depth,List<Integer> ans){
        if(root==null)
            return;
        if(ans.size()==depth)// 这个深度首次遇到
            ans.add(root.val);
        dfs(root.right,depth+1,ans);
        dfs(root.left,depth+1,ans);
    }
```

# 114 二叉树展开为链表
```java
    public void flatten(TreeNode root) {
        TreeNode curr = root;
        while (curr != null) {
            if (curr.left != null) {
                TreeNode next = curr.left;
                TreeNode predecessor = next;
                while (predecessor.right != null) {
                    predecessor = predecessor.right;
                }
                predecessor.right = curr.right;
                curr.left = null;
                curr.right = next;
            }
            curr = curr.right;
        }
    }
```

# 105 从前序和中序构造二叉树
```java
class Solution {
    private Map<Integer, Integer> indexMap; // 哈希表，存储每个节点值在中序遍历中的位置
    // 根据给定的前序遍历和中序遍历区间，递归构建二叉树
    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        // 如果当前区间无效，返回 null
        if (preorder_left > preorder_right)
            return null;
        int preorder_root = preorder_left;// 前序遍历的第一个节点是当前子树的根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);// 在中序遍历中找到根节点的位置

        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 计算左子树的节点数目，然后递归构建左右子树
        int size_left_subtree = inorder_root - inorder_left;
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    // 主函数：根据前序遍历和中序遍历构建整个二叉树
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        
        // 构造哈希映射，帮助快速定位中序遍历中根节点的位置
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i); // 记录每个值在中序遍历中的索引
        }
        // 从前序和中序遍历的完整区间开始递归构建树
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}
```
# 437 路径总和Ⅲ
`前缀和`
```java
    private HashMap<Long, Integer> prefixSum = new HashMap<>();  // 用于存储路径和的前缀和及其出现次数
    public int pathSum(TreeNode root, int targetSum) {
        prefixSum.put(0L, 1);  // 初始化，表示路径和为0出现了一次。这是为了处理从根节点开始就满足 targetSum 的情况
        dfs(root, 0L, (long) targetSum);  // 从根节点开始递归，初始路径和为0，目标和为targetSum
        return result;  // 返回符合条件的路径数目
    }
    private void dfs(TreeNode node, long currentSum, long targetSum) {
        if (node == null) return; 
        currentSum += node.val; // 更新当前路径和，加上当前节点的值
        // 判断当前路径和减去目标和是否在前缀和中存在
        result += prefixSum.getOrDefault(currentSum - targetSum, 0);  // 如果存在，说明有路径和为 targetSum，增加结果
        // 更新前缀和：记录当前路径和出现的次数
        prefixSum.put(currentSum, prefixSum.getOrDefault(currentSum, 0) + 1);
        // 递归遍历左子树和右子树
        dfs(node.left, currentSum, targetSum);
        dfs(node.right, currentSum, targetSum);
        // 回溯，恢复前缀和的状态
        prefixSum.put(currentSum, prefixSum.get(currentSum) - 1);  // 当遍历完当前节点的左右子树后，回溯时减少当前路径和的出现次数
    }
```

# 236 二叉树的最近公共祖先
```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || root==p ||root==q)
            return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        //左右子树都找到了p or q,则当前节点root就是所求
        if(left!=null && right!=null)
            return root;
        //否则转到非空的树去寻找
        return left!=null?left:right;
    }
```
# 二叉树的最大路径和
```java
 private int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }
    private int dfs(TreeNode node) {
        if (node == null)
            return 0;
        int lVal = dfs(node.left);//左子树最大链和
        int rVal = dfs(node.right);//右子树最大链和 
        ans = Math.max(ans, lVal + rVal + node.val);//左+右+节点，拼成路径
        return Math.max(Math.max(lVal, rVal) + node.val, 0);//当前字数最大链和
    }
```
# 岛屿问题
```java
    //通解dfs模板
    void dfs(char[][] grid, int r, int c) {
        if (!inArea(grid, r, c))
            return;
        if (grid[r][c] != '1')
            return;
        grid[r][c] = '2';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    boolean inArea(char[][] grid, int r, int c) {
        return 0 <= r && r < grid.length && c >= 0 && c < grid[0].length;
    }
```
# 994 腐烂的橘子
`BFS` `队列`
```java
    private static final int[][] DIR = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };
    public int orangesRotting(int[][] grid) {
        int m = grid.length, n = grid[0].length; // 获取网格的行数和列数
        int fresh = 0; // 统计新鲜橘子的数量
        Queue<int[]> q = new LinkedList<>(); // 存放腐烂橘子的队列

        for (int i = 0; i < m; i++) {//统计初始的好坏橘子
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) // 如果是新鲜橘子
                    fresh++;
                else if (grid[i][j] == 2) // 如果是腐烂橘子
                    q.offer(new int[] { i, j });
            }
        }
        int ans = 0; // 记录经过的分钟数
        // 当还有新鲜橘子且有腐烂橘子可以传播时
        while (fresh > 0 && !q.isEmpty()) {
            ans++; // 每轮代表一分钟
            int size = q.size(); // 当前层次的腐烂橘子数量
            // 遍历当前层次的腐烂橘子
            for (int k = 0; k < size; k++) {
                int[] pos = q.poll();
                for (int[] d : DIR) {
                    int i = pos[0] + d[0];
                    int j = pos[1] + d[1];
                    // 判断是否越界且是否为新鲜橘子
                    if (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1) {
                        fresh--; // 新鲜橘子数量减少
                        grid[i][j] = 2; // 将新鲜橘子腐烂
                        q.offer(new int[] { i, j }); // 加入腐烂橘子的队列
                    }
                }
            }
        }
        return fresh > 0 ? -1 : ans;
```
当前层次即刚被感染的橘子，然后把统计这些橘子的数量然后由他们作为污染源进行传播
# 207 课程表
`拓扑`
```java
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 构建邻接表表示有向图,graph[x]表示所有依赖于x的课程
        List<List<Integer>> graph = new ArrayList<>(numCourses);
        for (int i = 0; i < numCourses; i++)
            graph.add(new ArrayList<>());
        // 填充邻接表,p[1]为先修课程,p[0]为目标课程
        for (int[] p : prerequisites)
            graph.get(p[1]).add(p[0]);

        int[] visited = new int[numCourses]; // 标记节点状态：0-未访问，1-访问中，2-已访问
        //如果还没有被访问则检测是否有环
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0 && hasCycle(i, graph, visited))
                return false; // 存在环，不能完成课程
        }
        return true; // 无环，可以完成课程
    }

    // 深度优先搜索检测环
    private boolean hasCycle(int course, List<List<Integer>> graph, int[] visited) {
        visited[course] = 1; // 标记为访问中
        for (int next : graph.get(course)) { // 遍历邻接节点
            // 如果邻接节点是访问中，说明存在环
            if (visited[next] == 1)
                return true;
            // 如果邻接节点未访问且递归检测到环
            if (visited[next] == 0 && hasCycle(next, graph, visited))
                return true;
        }
        visited[course] = 2; // 标记为已访问
        return false;
    }
```
判断`visited[1]==1`只出现在判断函数中，不出现在主函数中，主函数只负责启动dfs，在主函数中只有未访问的节点才需要启动新dfs。
检测函数中，遍历graph中依赖于某课程的其余课程时，只需要判断1和0的情况，2仅需遍历之后做标记。

# 208 实现前缀树
`哈希`
```java
    private static class Node {
        Node[] children = new Node[26];//子节点数组
        boolean isEnd;//标记单词结束
    }
    private Node root = new Node();
    public void insert(String word) {
        Node current=find(word,true);
        current.isEnd=true;
    }
    public boolean search(String word) {
        Node node=find(word,false);
        return node!=null && node.isEnd;
    }
    public boolean startsWith(String prefix) {
        return find(prefix,false)!=null;
    }
    //查找并创建节点
    private Node find(String word,boolean needCreate){
        Node current=root;
        for(char c:word.toCharArray()){
            int index=c-'a';
            //子节点不存在，根据情况是否需要创建
            if(current.children[index]==null){
                if(needCreate)
                    current.children[index]=new Node();
                else
                    return null;
            }
            current=current.children[index];
        }
        return current;
    }
```
insert函数需要设置`isEnd=true`
search函数先判断`node!=null`表示从根节点找到了目标节点，即路径存在。然后判断`isEnd`表示是一个完整的单词

# 46 全排列
`回溯`
```java
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<>>();
        List<Integer> output = new ArrayList<>();
        for (int num : nums)//初始化排列列表，将元素逐一加入
            output.add(num);
        int n = nums.length;
        backtrack(n, 0, output, ans);
        return ans;
    }
    public void backtrack(int n, int index, List<Integer> output, List<List<Integer>> ans) {
        if (index == n)//排列长度等于数组长度时，将当前的output加入ans
            ans.add(new ArrayList<Integer>(output));
        for (int i = index; i < n; i++) {
            //1.交换：将index和i交换位置
            Collections.swap(output, index, i);
            //2.递归：排列下一个位置
            backtrack(n, index + 1, output, ans);
            //3.回溯：把index和i交换回来
            Collections.swap(output, index, i);
        }
    }
```
index代表当前固定位置，逐步固定元素之后，再交换index之后的元素位置，然后再回溯。

# 78 子集
`回溯`
```java
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        backtrack(0, nums, ans, new ArrayList<>());
        return ans;
    }
    public void backtrack(int index, int[] nums, List<List<Integer>> ans, List<Integer> path) {
        //把当前路径加入答案列表
        ans.add(new ArrayList<>(path));
        int len = nums.length;
        for (int i = index; i < len; i++) {
            //当前元素加入路径
            path.add(nums[i]);
            //继续向后寻找包含当前元素的后续子集
            backtrack(i + 1, nums, ans, path);
            //回溯，移除最后一个加入的元素
            path.remove(path.size() - 1);
        }
    }
```

# 17 电话号码的字母组合
`回溯`
```java
    List<String> ans = new ArrayList<>();
    StringBuilder temp = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0)
            return ans;
        String[] numString = { "", "", "abc", "def", "ghi", \
            "jkl", "mno", "pqrs", "tuv", "wxyz" };
        backTracking(digits, numString, 0);
        return ans;
    }
    //index 当前处理的数字位置的索引
    public void backTracking(String digits, String[] numString, int index) {
        if (num == digits.length()) {
            list.add(temp.toString());
            return;
        }
        String str = numString[digits.charAt(index) - '0'];
        for (int i = 0; i < str.length(); i++) {
            //将字母加入当前组合
            temp.append(str.charAt(i));
            //递归，继续生成下一位数字的组合
            backTracking(digits, numString, index + 1);
            //回溯
            temp.deleteCharAt(temp.length() - 1);
        }
    }
```
java处理字符串先定义stringBuilder对象
# 38 组合总和
`·回溯`
```java
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> ans = new ArrayList();
        List<Integer> path = new ArrayList();
        backtrack(target, 0, candidates, ans, path);
        return ans;
    }
    public void backtrack(int target, int index, int[] candidates, List<List<Integer>> ans, List<Integer> path) {
        if (target == 0) {
            ans.add(new ArrayList<>(path));
            return;
        }
        if (target < candidates[index])
            return;
        for (int i = index; i < candidates.length; i++) {
            path.add(candidates[i]);
            backtrack(target - candidates[i], i, candidates, ans, path);
            path.remove(path.size() - 1);
        }
    }
```
先将`canditates`排序，依旧回溯

# 22 括号生成
`递归`
```java
    public List<String> generateParenthesis(int n) {
        List<String>ans=new ArrayList<>();
        dfs("",n,n,ans);
        return ans;
    }
    public void dfs(String str,int left,int right,List<String> ans){
        //左右括号都为0，说明生成了一个合法组合
        if(left==0 && right==0)
            ans.add(str);
        if(left>0)
            dfs(str+"(",left-1,right,ans);
        if(left<right)
            dfs(str+")",left,right-1,ans);
    }
```
left为剩余可以放置的左括号数量，right为剩余可以放置的右括号数量
1. 如果还有左括号可以放，就递归地添加一个左括号
2. 如果右括号数量多于左括号，说明可以放右括号

# 51 N皇后
`回溯` `位运算`
```java
    List<List<String>> ans=new ArrayList<>();
    char[][] board;
    public List<List<String>> solveNQueens(int n) {
        board=new char[n][n];
        for(char[] row:board)
            Arrays.fill(row,'.');
        backtrack(0,0,0,0,n);
        return ans;
    }
    public void backtrack(int row,int a,int b,int c,int n){
        if(row==n){
            List<String> tmp=new ArrayList<>();
            for(char[] r:board)
                tmp.add(new String(r));
            ans.add(tmp);
        }
        int mask=(1<<n)-1;
        int available=~(a|b|c) &mask;
        while(available>0){
            int bit=available & -available;
            int col=Integer.numberOfTrailingZeros(bit);
            board[row][col]='Q';
            backtrack(row+1,(a|bit)<<1,b|bit,(c|bit)>>1,n);
            board[row][col]='.';
            available-=bit;
        }
    }
```
(a：主对角线，b：当前列，c：副对角线)是否有皇后

`mask=(1 << n) - 1`用来创建一个后n位均为1的二进制数，`a|b|c`把三个障碍位合并，得到所有不能放皇后的地方，取反则为能放的位置，`&mask`操作则用于清除高位无关信息，只保留1

计算bit的操作则为提取available中第一个1，`numberOfTrailingZeros(bit)`则为bit末尾几个0，也就是1在从右往左第几位，也就是皇后应该放到哪一列

# 74 搜索二维矩阵
`二分`
```java
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int left = 0, right = m * n-1;
        while(left<=right){
            int mid=(left+right)>>1;
            int x=matrix[mid/n][mid%n];
            if(x==target)
                return true;
            else if(x<target)
                left=mid+1;
            else
                right=mid-1;
        }
        return false;
    }
```
将二维数组看作一维数组,数组下标i,j与位置k的关系：```java i = k / n,j = k % n;```
注意边界条件，采用闭区间[0,mn-1];

# 34 在排序数组中查找元素的第一个和最后一个位置
`二分`
```java
    public int[] searchRange(int[] nums, int target) {
        int start=lowerBound(nums,target);
        if(start==nums.length || nums[start]!=target)
            return new int[]{-1,-1};
        int end=lowerBound(nums,target+1)-1;
        return new int[]{start,end};
    }
    public int lowerBound(int[] nums,int target){
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=(left+right)>>1;
            if(nums[mid]>=target)
                right=mid-1;
            else
                left=mid+1;
        }
        return left;
    }
```
依旧闭区间

# 33 搜索旋转排序数组
`二分`
```java
    public int search(int[] nums, int target) {
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=(left+right)>>1;
            if(check(mid,target,nums))
                right=mid-1;
            else
                left=mid+1;
        }
        //left指向第一个满足条件的位置，也可能是找不到的插入点(注意最后的返回条件)
        if(left<nums.length && nums[left]==target)
            return left;
        return -1;
    }
    public boolean check(int index,int target,int[] nums){
        int mid=nums[index];//中间元素
        int end=nums[nums.length-1];//末尾元素
        if(mid>end)//nums被分为两段，前半部分比较大【3，4，5，6，1，2】
            return target>end && mid>=target;
        return target>end || mid>=target;
    }
```
`check`函数判断target在mid的左侧还是右侧(重中之重)，左侧为true，右侧为false
先判断`mid`在哪段：如果`mid > end`，说明在左段，否则在右段
再判断 target 是不是在 mid 的“左边”：在同一段：看大小关系,不在一段：看是不是左段或右段

# 寻找旋转排序数组中的最小值
`二分`
```java
    public int findMin(int[] nums) {
        int n = nums.length;
        int left = 0, right = n - 1;
        while (left < right) {
            int mid = (left+right)>>1;
            if (nums[mid] <= nums[right]) {
                right = mid; // 包含 mid
            } else {
                left = mid + 1; // 排除 mid
            }
        }
        return nums[left];
    }
```

# 有效的括号
`栈`
```java
    public boolean isValid(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) return false;
                char top = stack.pop();
                if ((c == ')' && top != '(') ||
                    (c == ']' && top != '[') ||
                    (c == '}' && top != '{')) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
```
循环遍历字符串，碰见左括号则入栈，碰见右括号则看栈顶是否匹配。注意栈的isEmpty()用法

# 字符串解码
`栈`
```java
    public String decodeString(String s) {
        Deque<Integer> countStack=new ArrayDeque<>();
        Deque<StringBuilder> stringStack=new ArrayDeque<>();
        StringBuilder cur=new StringBuilder();
        int k=0;
        for(char ch:s.toCharArray()){
            if(Character.isDigit(ch))
                k=k*10+ch-'0';
            else if(ch=='['){
                //马上碰见新的字符时，先保存次数k，并把之前的字符串入栈保存
                countStack.push(k);
                stringStack.push(cur);
                cur=new StringBuilder();
                k=0;
            }
            else if(ch==']'){
                //结束一个字符串，弹出k和之前字符串，并把正在处理的拼接在prev之后
                int tmp=countStack.pop();
                StringBuilder prev=stringStack.pop();
                for(int i=0;i<tmp;i++)
                    prev.append(cur);
                cur=prev;
            }
            else{
                cur.append(ch);
            }
        }
        return cur.toString();
    }
```
stringStack存放每次遇到'['之前已经构造的字符串，countStack存放数字k，cur为当前正在处理的字符串

# 每日温度
`栈`
```java
    public int[] dailyTemperatures(int[] temperatures) {
        int len=temperatures.length;
        int[] ans=new int[len];
        Deque<Integer> stack=new LinkedList<Integer>();
        for(int i=0;i<len;i++){
            int tmp=temperatures[i];
            while(!stack.isEmpty() && tmp>temperatures[stack.peek()]){
                int prevIndex=stack.pop();
                ans[prevIndex]=i-prevIndex;
            }
            stack.push(i);
        }
        return ans;
    }
```
peek获取索引，栈中寸的是索引

# 84 柱状图中最大的矩形
`栈`
```java
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int ans = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i <= n; i++) {
            //获取当前高度，i==n时视为0(哨兵)
            int curHeight = (i == n) ? 0 : heights[i];
            //当前柱子高度小于栈顶柱子时开始计算面积
            while (!stack.isEmpty() && curHeight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                //栈空了，说明左边没有比他小的柱子，宽度为i。否则宽度为后者
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                ans = Math.max(ans, height * width);
            }
            //当前柱子的下标入栈
            stack.push(i);
        }
        return ans;
    }
```
for循环的条件为`i<=n`
栈中保存的是递增的柱子下标，也就是说，栈顶的柱子是到目前为止最高的、尚未结算面积的柱子。
`i==n`时，哨兵=0的作用是“我比你们都矮，你们都别等了，都赶紧结算吧”,把之前入栈但未处理的柱子全部计算面积。

# 215 数组中的第K个最大元素
`快排`
```java
    public int findKthLargest(int[] nums, int k) {
        int n=nums.length;
        return quickSelect(nums,0,n-1,n-k);
    }
    public int quickSelect(int[] nums,int l,int r,int k){
        if(l==r) return nums[k];
        int pivot=nums[l],i=l,j=r;
        while(i<=j){
            while(i<=j && nums[i]<pivot)    i++;
            while(i<=j && nums[j]>pivot)    j--;
            if(i>=j)    break;
            swap(nums,i,j);
            i++;
            j--;
        }
        return (k<=j)?quickSelect(nums,l,j,k):quickSelect(nums,j+1,r,k);
    }
    public void swap(int[] nums,int a,int b){
        int tmp=nums[a];
        nums[a]=nums[b];
        nums[b]=tmp;
    }
```
主要就是主函数调用时`quickSelect(nums,0,n-1,n-k)`,快排本质是找第k小的元素，所以要进行转化。


